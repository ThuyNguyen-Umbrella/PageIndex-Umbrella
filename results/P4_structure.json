{
  "doc_name": "P4.pdf",
  "structure": [
    {
      "title": "P4: Programming Protocol-Independent Packet Processors",
      "start_index": 1,
      "end_index": 1,
      "nodes": [
        {
          "title": "ABSTRACT",
          "start_index": 1,
          "end_index": 1,
          "node_id": "0001",
          "text": "<physical_index_1>\nP4: Programming Protocol-Independent\nPacket Processors\nPat Bossharty, Dan Daly*, Glen Gibby, Martin Izzardy, Nick McKeownz, Jennifer Rexford**,\nCole Schlesinger**, Dan Talaycoy, Amin Vahdat{, George Varghesex, David Walker**\nyBarefoot Networks*IntelzStanford University**Princeton University{GooglexMicrosoft Research\nABSTRACT\nP4 is a high-level language for programming protocol-inde-\npendent packet processors. P4 works in conjunction with\nSDN control protocols like OpenFlow. In its current form,\nOpenFlow explicitly speci\fes protocol headers on which it\noperates. This set has grown from 12 to 41 \felds in a few\nyears, increasing the complexity of the speci\fcation while\nstill not providing the \rexibility to add new headers. In this\npaper we propose P4 as a strawman proposal for how Open-\nFlow should evolve in the future. We have three goals: (1)\nRecon\fgurability in the \feld: Programmers should be able\nto change the way switches process packets once they are\ndeployed. (2) Protocol independence: Switches should not\nbe tied to any speci\fc network protocols. (3) Target inde-\npendence: Programmers should be able to describe packet-\nprocessing functionality independently of the speci\fcs of the\nunderlying hardware. As an example, we describe how to\nuse P4 to con\fgure a switch to add a new hierarchical label.\n1. INTRODUCTION\nSoftware-De\fned Networking (SDN) gives operators pro-\ngrammatic control over their networks. In SDN, the con-\ntrol plane is physically separate from the forwarding plane,\nand one control plane controls multiple forwarding devices.\nWhile forwarding devices could be programmed in many\nways, having a common, open, vendor-agnostic interface\n(like OpenFlow) enables a control plane to control forward-\ning devices from di\u000berent hardware and software vendors.\nVersion Date Header Fields\nOF 1.0 Dec 2009 12 \felds (Ethernet, TCP/IPv4)\nOF 1.1 Feb 2011 15 \felds (MPLS, inter-table metadata)\nOF 1.2 Dec 2011 36 \felds (ARP, ICMP, IPv6, etc.)\nOF 1.3 Jun 2012 40 \felds\nOF 1.4 Oct 2013 41 \felds\nTable 1: Fields recognized by the OpenFlow standard\nThe OpenFlow interface started simple, with the abstrac-\ntion of a single table of rules that could match packets on a\ndozen header \felds (e.g., MAC addresses, IP addresses, pro-\ntocol, TCP/UDP port numbers, etc.). Over the past \fve\nyears, the speci\fcation has grown increasingly more com-\nplicated (see Table 1), with many more header \felds andmultiple stages of rule tables, to allow switches to expose\nmore of their capabilities to the controller.\nThe proliferation of new header \felds shows no signs of\nstopping. For example, data-center network operators in-\ncreasingly want to apply new forms of packet encapsula-\ntion (e.g., NVGRE, VXLAN, and STT), for which they re-\nsort to deploying software switches that are easier to extend\nwith new functionality. Rather than repeatedly extending\nthe OpenFlow speci\fcation, we argue that future switches\nshould support \rexible mechanisms for parsing packets and\nmatching header \felds, allowing controller applications to\nleverage these capabilities through a common, open inter-\nface (i.e., a new \\OpenFlow 2.0\" API). Such a general, ex-\ntensible approach would be simpler, more elegant, and more\nfuture-proof than today's OpenFlow 1.x standard.\nFigure 1: P4 is a language to con\fgure switches.\nRecent chip designs demonstrate that such \rexibility can\nbe achieved in custom ASICs at terabit speeds [1, 2, 3]. Pro-\ngramming this new generation of switch chips is far from\neasy. Each chip has its own low-level interface, akin to\nmicrocode programming. In this paper, we sketch the de-\nsign of a higher-level language for Programming Protocol-\nindependent Packet Processors (P4). Figure 1 shows the\nrelationship between P4|used to con\fgure a switch, telling\nit how packets are to be processed|and existing APIs (such\nas OpenFlow) that are designed to populate the forwarding\ntables in \fxed function switches. P4 raises the level of ab-\nstraction for programming the network, and can serve as a\nACM SIGCOMM Computer Communication Review\n88\nVolume 44, Number 3, July 2014\n<physical_index_1>\n"
        },
        {
          "title": "1. INTRODUCTION",
          "start_index": 1,
          "end_index": 2,
          "node_id": "0002",
          "text": "<physical_index_1>\nP4: Programming Protocol-Independent\nPacket Processors\nPat Bossharty, Dan Daly*, Glen Gibby, Martin Izzardy, Nick McKeownz, Jennifer Rexford**,\nCole Schlesinger**, Dan Talaycoy, Amin Vahdat{, George Varghesex, David Walker**\nyBarefoot Networks*IntelzStanford University**Princeton University{GooglexMicrosoft Research\nABSTRACT\nP4 is a high-level language for programming protocol-inde-\npendent packet processors. P4 works in conjunction with\nSDN control protocols like OpenFlow. In its current form,\nOpenFlow explicitly speci\fes protocol headers on which it\noperates. This set has grown from 12 to 41 \felds in a few\nyears, increasing the complexity of the speci\fcation while\nstill not providing the \rexibility to add new headers. In this\npaper we propose P4 as a strawman proposal for how Open-\nFlow should evolve in the future. We have three goals: (1)\nRecon\fgurability in the \feld: Programmers should be able\nto change the way switches process packets once they are\ndeployed. (2) Protocol independence: Switches should not\nbe tied to any speci\fc network protocols. (3) Target inde-\npendence: Programmers should be able to describe packet-\nprocessing functionality independently of the speci\fcs of the\nunderlying hardware. As an example, we describe how to\nuse P4 to con\fgure a switch to add a new hierarchical label.\n1. INTRODUCTION\nSoftware-De\fned Networking (SDN) gives operators pro-\ngrammatic control over their networks. In SDN, the con-\ntrol plane is physically separate from the forwarding plane,\nand one control plane controls multiple forwarding devices.\nWhile forwarding devices could be programmed in many\nways, having a common, open, vendor-agnostic interface\n(like OpenFlow) enables a control plane to control forward-\ning devices from di\u000berent hardware and software vendors.\nVersion Date Header Fields\nOF 1.0 Dec 2009 12 \felds (Ethernet, TCP/IPv4)\nOF 1.1 Feb 2011 15 \felds (MPLS, inter-table metadata)\nOF 1.2 Dec 2011 36 \felds (ARP, ICMP, IPv6, etc.)\nOF 1.3 Jun 2012 40 \felds\nOF 1.4 Oct 2013 41 \felds\nTable 1: Fields recognized by the OpenFlow standard\nThe OpenFlow interface started simple, with the abstrac-\ntion of a single table of rules that could match packets on a\ndozen header \felds (e.g., MAC addresses, IP addresses, pro-\ntocol, TCP/UDP port numbers, etc.). Over the past \fve\nyears, the speci\fcation has grown increasingly more com-\nplicated (see Table 1), with many more header \felds andmultiple stages of rule tables, to allow switches to expose\nmore of their capabilities to the controller.\nThe proliferation of new header \felds shows no signs of\nstopping. For example, data-center network operators in-\ncreasingly want to apply new forms of packet encapsula-\ntion (e.g., NVGRE, VXLAN, and STT), for which they re-\nsort to deploying software switches that are easier to extend\nwith new functionality. Rather than repeatedly extending\nthe OpenFlow speci\fcation, we argue that future switches\nshould support \rexible mechanisms for parsing packets and\nmatching header \felds, allowing controller applications to\nleverage these capabilities through a common, open inter-\nface (i.e., a new \\OpenFlow 2.0\" API). Such a general, ex-\ntensible approach would be simpler, more elegant, and more\nfuture-proof than today's OpenFlow 1.x standard.\nFigure 1: P4 is a language to con\fgure switches.\nRecent chip designs demonstrate that such \rexibility can\nbe achieved in custom ASICs at terabit speeds [1, 2, 3]. Pro-\ngramming this new generation of switch chips is far from\neasy. Each chip has its own low-level interface, akin to\nmicrocode programming. In this paper, we sketch the de-\nsign of a higher-level language for Programming Protocol-\nindependent Packet Processors (P4). Figure 1 shows the\nrelationship between P4|used to con\fgure a switch, telling\nit how packets are to be processed|and existing APIs (such\nas OpenFlow) that are designed to populate the forwarding\ntables in \fxed function switches. P4 raises the level of ab-\nstraction for programming the network, and can serve as a\nACM SIGCOMM Computer Communication Review\n88\nVolume 44, Number 3, July 2014\n<physical_index_1>\n<physical_index_2>\ngeneral interface between the controller and the switches.\nThat is, we believe that future generations of OpenFlow\nshould allow the controller to tell the switch how to operate,\nrather than be constrained by a \fxed switch design. The key\nchallenge is to \fnd a \\sweet spot\" that balances the need\nfor expressiveness with the ease of implementation across a\nwide range of hardware and software switches. In designing\nP4, we have three main goals:\n\u000fRecon\fgurability. The controller should be able to re-\nde\fne the packet parsing and processing in the \feld.\n\u000fProtocol independence. The switch should not be tied\nto speci\fc packet formats. Instead, the controller should\nbe able to specify (i) a packet parser for extracting header\n\felds with particular names and types and (ii) a collection\nof typed match +action tables that process these headers.\n\u000fTarget independence. Just as a C programmer does\nnot need to know the speci\fcs of the underlying CPU, the\ncontroller programmer should not need to know the de-\ntails of the underlying switch. Instead, a compiler should\ntake the switch's capabilities into account when turning\na target-independent description (written in P4) into a\ntarget-dependent program (used to con\fgure the switch).\nThe outline of the paper is as follows. We begin by in-\ntroducing an abstract switch forwarding model. Next, we\nexplain the need for a new language to describe protocol-\nindependent packet processing. We then present a simple\nmotivating example where a network operator wants to sup-\nport a new packet-header \feld and process packets in mul-\ntiple stages. We use this to explore how the P4 program\nspeci\fes headers, the packet parser, the multiple match +\naction tables, and the control \row through these tables. Fi-\nnally, we discuss how a compiler can map P4 programs to\ntarget switches.\nRelated work. In 2011, Yadav et al. [4] proposed an ab-\nstract forwarding model for OpenFlow, but with less empha-\nsis on a compiler. Kangaroo [1] introduced the notion of pro-\ngrammable parsing. Recently, Song [5] proposed protocol-\noblivious forwarding which shares our goal of protocol in-\ndependence, but is targeted more towards network proces-\nsors. The ONF introduced table typing patterns to express\nthe matching capabilities of switches [6]. Recent work on\nNOSIX [7] shares our goal of \rexible speci\fcation of match +\naction tables, but does not consider protocol-independence\nor propose a language for specifying the parser, tables, and\ncontrol \row. Other recent work proposes a programmatic in-\nterface to the data plane for monitoring, congestion control,\nand queue management [8, 9]. The Click modular router [10]\nsupports \rexible packet processing in software, but does not\nmap programs to a variety of target hardware switches.\n2. ABSTRACT FORWARDING MODEL\nIn our abstract model (Fig. 2), switches forward packets\nvia a programmable parser followed by multiple stages of\nmatch +action, arranged in series, parallel, or a combination\nof both. Derived from OpenFlow, our model makes threegeneralizations. First, OpenFlow assumes a \fxed parser,\nwhereas our model supports a programmable parser to allow\nnew headers to be de\fned. Second, OpenFlow assumes the\nmatch +action stages are in series, whereas in our model they\ncan be in parallel or in series. Third, our model assumes that\nactions are composed from protocol-independent primitives\nsupported by the switch.\nOur abstract model generalizes how packets are processed\nin di\u000berent forwarding devices (e.g., Ethernet switches, load-\nbalancers, routers) and by di\u000berent technologies (e.g., \fxed-\nfunction switch ASICs, NPUs, recon\fgurable switches, soft-\nware switches, FPGAs). This allows us to devise a com-\nmon language (P4) to represent how packets are processed\nin terms of our common abstract model. Hence, program-\nmers can create target-independent programs that a com-\npiler can map to a variety of di\u000berent forwarding devices,\nranging from relatively slow software switches to the fastest\nASIC-based switches.\nFigure 2: The abstract forwarding model.\nThe forwarding model is controlled by two types of oper-\nations: Con\fgure and Populate. Con\fgure operations pro-\ngram the parser, set the order of match +action stages, and\nspecify the header \felds processed by each stage. Con\fg-\nuration determines which protocols are supported and how\nthe switch may process packets. Populate operations add\n(and remove) entries to the match +action tables that were\nspeci\fed during con\fguration. Population determines the\npolicy applied to packets at any given time.\nFor the purposes of this paper, we assume that con\fgura-\ntion and population are two distinct phases. In particular,\nthe switch need not process packets during con\fguration.\nHowever, we expect implementations will allow packet pro-\ncessing during partial or full recon\fguration enabling up-\ngrades with no downtime. Our model deliberately allows\nfor, and encourages, recon\fguration that does not interrupt\nforwarding.\nClearly, the con\fguration phase has little meaning in \fxed-\nfunction ASIC switches; for this type of switch, the com-\nACM SIGCOMM Computer Communication Review\n89\nVolume 44, Number 3, July 2014\n<physical_index_2>\n"
        },
        {
          "title": "2. ABSTRACT FORWARDING MODEL",
          "start_index": 2,
          "end_index": 3,
          "node_id": "0003",
          "text": "<physical_index_2>\ngeneral interface between the controller and the switches.\nThat is, we believe that future generations of OpenFlow\nshould allow the controller to tell the switch how to operate,\nrather than be constrained by a \fxed switch design. The key\nchallenge is to \fnd a \\sweet spot\" that balances the need\nfor expressiveness with the ease of implementation across a\nwide range of hardware and software switches. In designing\nP4, we have three main goals:\n\u000fRecon\fgurability. The controller should be able to re-\nde\fne the packet parsing and processing in the \feld.\n\u000fProtocol independence. The switch should not be tied\nto speci\fc packet formats. Instead, the controller should\nbe able to specify (i) a packet parser for extracting header\n\felds with particular names and types and (ii) a collection\nof typed match +action tables that process these headers.\n\u000fTarget independence. Just as a C programmer does\nnot need to know the speci\fcs of the underlying CPU, the\ncontroller programmer should not need to know the de-\ntails of the underlying switch. Instead, a compiler should\ntake the switch's capabilities into account when turning\na target-independent description (written in P4) into a\ntarget-dependent program (used to con\fgure the switch).\nThe outline of the paper is as follows. We begin by in-\ntroducing an abstract switch forwarding model. Next, we\nexplain the need for a new language to describe protocol-\nindependent packet processing. We then present a simple\nmotivating example where a network operator wants to sup-\nport a new packet-header \feld and process packets in mul-\ntiple stages. We use this to explore how the P4 program\nspeci\fes headers, the packet parser, the multiple match +\naction tables, and the control \row through these tables. Fi-\nnally, we discuss how a compiler can map P4 programs to\ntarget switches.\nRelated work. In 2011, Yadav et al. [4] proposed an ab-\nstract forwarding model for OpenFlow, but with less empha-\nsis on a compiler. Kangaroo [1] introduced the notion of pro-\ngrammable parsing. Recently, Song [5] proposed protocol-\noblivious forwarding which shares our goal of protocol in-\ndependence, but is targeted more towards network proces-\nsors. The ONF introduced table typing patterns to express\nthe matching capabilities of switches [6]. Recent work on\nNOSIX [7] shares our goal of \rexible speci\fcation of match +\naction tables, but does not consider protocol-independence\nor propose a language for specifying the parser, tables, and\ncontrol \row. Other recent work proposes a programmatic in-\nterface to the data plane for monitoring, congestion control,\nand queue management [8, 9]. The Click modular router [10]\nsupports \rexible packet processing in software, but does not\nmap programs to a variety of target hardware switches.\n2. ABSTRACT FORWARDING MODEL\nIn our abstract model (Fig. 2), switches forward packets\nvia a programmable parser followed by multiple stages of\nmatch +action, arranged in series, parallel, or a combination\nof both. Derived from OpenFlow, our model makes threegeneralizations. First, OpenFlow assumes a \fxed parser,\nwhereas our model supports a programmable parser to allow\nnew headers to be de\fned. Second, OpenFlow assumes the\nmatch +action stages are in series, whereas in our model they\ncan be in parallel or in series. Third, our model assumes that\nactions are composed from protocol-independent primitives\nsupported by the switch.\nOur abstract model generalizes how packets are processed\nin di\u000berent forwarding devices (e.g., Ethernet switches, load-\nbalancers, routers) and by di\u000berent technologies (e.g., \fxed-\nfunction switch ASICs, NPUs, recon\fgurable switches, soft-\nware switches, FPGAs). This allows us to devise a com-\nmon language (P4) to represent how packets are processed\nin terms of our common abstract model. Hence, program-\nmers can create target-independent programs that a com-\npiler can map to a variety of di\u000berent forwarding devices,\nranging from relatively slow software switches to the fastest\nASIC-based switches.\nFigure 2: The abstract forwarding model.\nThe forwarding model is controlled by two types of oper-\nations: Con\fgure and Populate. Con\fgure operations pro-\ngram the parser, set the order of match +action stages, and\nspecify the header \felds processed by each stage. Con\fg-\nuration determines which protocols are supported and how\nthe switch may process packets. Populate operations add\n(and remove) entries to the match +action tables that were\nspeci\fed during con\fguration. Population determines the\npolicy applied to packets at any given time.\nFor the purposes of this paper, we assume that con\fgura-\ntion and population are two distinct phases. In particular,\nthe switch need not process packets during con\fguration.\nHowever, we expect implementations will allow packet pro-\ncessing during partial or full recon\fguration enabling up-\ngrades with no downtime. Our model deliberately allows\nfor, and encourages, recon\fguration that does not interrupt\nforwarding.\nClearly, the con\fguration phase has little meaning in \fxed-\nfunction ASIC switches; for this type of switch, the com-\nACM SIGCOMM Computer Communication Review\n89\nVolume 44, Number 3, July 2014\n<physical_index_2>\n<physical_index_3>\npiler's job is to simply check if the chip can support the P4\nprogram. Instead, our goal is to capture the general trend\ntowards fast recon\fgurable packet-processing pipelines, as\ndescribed in [2, 3].\nArriving packets are \frst handled by the parser. The\npacket body is assumed to be bu\u000bered separately, and un-\navailable for matching. The parser recognizes and extracts\n\felds from the header, and thus de\fnes the protocols sup-\nported by the switch. The model makes no assumptions\nabout the meaning of protocol headers, only that the parsed\nrepresentation de\fnes a collection of \felds on which match-\ning and actions operate.\nThe extracted header \felds are then passed to the match +\naction tables. The match +action tables are divided be-\ntween ingress and egress. While both may modify the packet\nheader, ingress match +action determines the egress port(s)\nand determines the queue into which the packet is placed.\nBased on ingress processing, the packet may be forwarded,\nreplicated (for multicast, span, or to the control plane),\ndropped, or trigger \row control. Egress match +action per-\nforms per-instance modi\fcations to the packet header { e.g.,\nfor multicast copies. Action tables (counters, policers, etc.)\ncan be associated with a \row to track frame-to-frame state.\nPackets can carry additional information between stages,\ncalled metadata, which is treated identically to packet header\n\felds. Some examples of metadata include the ingress port,\nthe transmit destination and queue, a timestamp that can\nbe used for packet scheduling, and data passed from table-\nto-table that does not involve changing the parsed represen-\ntation of the packet such as a virtual network identi\fer.\nQueueing disciplines are handled in the same way as the\ncurrent OpenFlow: an action maps a packet to a queue,\nwhich is con\fgured to receive a particular service discipline.\nThe service discipline (e.g., minimum rate, DRR) is chosen\nas part of the switch con\fguration.\nAlthough beyond the scope of this paper, action primi-\ntives can be added to allow the programmer to implement\nnew or existing congestion control protocols. For example,\nthe switch might be programmed to set the ECN bit based\non novel conditions, or it might implement a proprietary\ncongestion control mechanism using match +action tables.\n3. A PROGRAMMING LANGUAGE\nWe use the abstract forwarding model to de\fne a lan-\nguage to express how a switch is to be con\fgured and how\npackets are to be processed. This paper's main goal is to\npropose the P4 programming language. However, we recog-\nnize that many languages are possible, and they will likely\nshare the common characteristics we describe here. For ex-\nample, the language needs a way to express how the parser is\nprogrammed so that the parser knows what packet formats\nto expect; hence a programmer needs a way to declare what\nheader types are possible. As an example, the programmer\ncould specify the format of an IPv4 header and what headers\nmay legally follow the IP header. This motivates de\fningparsing in P4 by declaring legal header types. Similarly, the\nprogrammer needs to express how packet headers are to be\nprocessed. For example, TTL \felds must be decremented\nand tested, new tunnel headers may need to be added, and\nchecksums may need to be computed. This motivates P4's\nuse of an imperative control \row program to describe header\n\feld processing using the declared header types and a prim-\nitive set of actions.\nWe could use a language such as Click [10], which builds\nswitches from modules composed of arbitrary C++. Click is\nextremely expressive, and very suitable for expressing how\npackets are processed in the kernel of a CPU. But it is in-\nsu\u000eciently constrained for our needs|we need a language\nthat mirrors the parse-match-action pipelines in dedicated\nhardware. In addition, Click is not designed for a controller-\nswitch architecture and hence does not allow programmers\nto describe match +action tables that are dynamically pop-\nulated by well-typed rules. Finally, Click makes it di\u000ecult\nto infer dependencies that constrain parallel execution|as\nwe now discuss.\nA packet processing language must allow the programmer\nto express (implicitly or explicitly) any serial dependencies\nbetween header \felds. Dependencies determine which ta-\nbles can be executed in parallel. For example, sequential\nexecution is required for an IP routing table and an ARP\ntable due to the data dependency between them. Dependen-\ncies can be identi\fed by analyzing Table Dependency Graphs\n(TDGs); these graphs describe the \feld inputs, actions, and\ncontrol \row between tables. Figure 3 shows an example ta-\nble dependency graph for an L2/L3 switch. TDG nodes map\ndirectly to match +action tables, and a dependency analy-\nsis identi\fes where each table may reside in the pipeline.\nUnfortunately TDGs are not readily accessible to most pro-\ngrammers; programmers tend to think of packet processing\nalgorithms using imperative constructs rather than graphs.\nFigure 3: Table dependency graph for an L2/L3\nswitch.\nThis leads us to propose a two-step compilation process.\nAt the highest level, programmers express packet process-\ning programs using an imperative language representing the\ncontrol \row (P4); below this, a compiler translates the P4\nrepresentation to TDGs to facilitate dependency analysis,\nACM SIGCOMM Computer Communication Review\n90\nVolume 44, Number 3, July 2014\n<physical_index_3>\n"
        },
        {
          "title": "3. A PROGRAMMING LANGUAGE",
          "start_index": 3,
          "end_index": 5,
          "node_id": "0004",
          "text": "<physical_index_3>\npiler's job is to simply check if the chip can support the P4\nprogram. Instead, our goal is to capture the general trend\ntowards fast recon\fgurable packet-processing pipelines, as\ndescribed in [2, 3].\nArriving packets are \frst handled by the parser. The\npacket body is assumed to be bu\u000bered separately, and un-\navailable for matching. The parser recognizes and extracts\n\felds from the header, and thus de\fnes the protocols sup-\nported by the switch. The model makes no assumptions\nabout the meaning of protocol headers, only that the parsed\nrepresentation de\fnes a collection of \felds on which match-\ning and actions operate.\nThe extracted header \felds are then passed to the match +\naction tables. The match +action tables are divided be-\ntween ingress and egress. While both may modify the packet\nheader, ingress match +action determines the egress port(s)\nand determines the queue into which the packet is placed.\nBased on ingress processing, the packet may be forwarded,\nreplicated (for multicast, span, or to the control plane),\ndropped, or trigger \row control. Egress match +action per-\nforms per-instance modi\fcations to the packet header { e.g.,\nfor multicast copies. Action tables (counters, policers, etc.)\ncan be associated with a \row to track frame-to-frame state.\nPackets can carry additional information between stages,\ncalled metadata, which is treated identically to packet header\n\felds. Some examples of metadata include the ingress port,\nthe transmit destination and queue, a timestamp that can\nbe used for packet scheduling, and data passed from table-\nto-table that does not involve changing the parsed represen-\ntation of the packet such as a virtual network identi\fer.\nQueueing disciplines are handled in the same way as the\ncurrent OpenFlow: an action maps a packet to a queue,\nwhich is con\fgured to receive a particular service discipline.\nThe service discipline (e.g., minimum rate, DRR) is chosen\nas part of the switch con\fguration.\nAlthough beyond the scope of this paper, action primi-\ntives can be added to allow the programmer to implement\nnew or existing congestion control protocols. For example,\nthe switch might be programmed to set the ECN bit based\non novel conditions, or it might implement a proprietary\ncongestion control mechanism using match +action tables.\n3. A PROGRAMMING LANGUAGE\nWe use the abstract forwarding model to de\fne a lan-\nguage to express how a switch is to be con\fgured and how\npackets are to be processed. This paper's main goal is to\npropose the P4 programming language. However, we recog-\nnize that many languages are possible, and they will likely\nshare the common characteristics we describe here. For ex-\nample, the language needs a way to express how the parser is\nprogrammed so that the parser knows what packet formats\nto expect; hence a programmer needs a way to declare what\nheader types are possible. As an example, the programmer\ncould specify the format of an IPv4 header and what headers\nmay legally follow the IP header. This motivates de\fningparsing in P4 by declaring legal header types. Similarly, the\nprogrammer needs to express how packet headers are to be\nprocessed. For example, TTL \felds must be decremented\nand tested, new tunnel headers may need to be added, and\nchecksums may need to be computed. This motivates P4's\nuse of an imperative control \row program to describe header\n\feld processing using the declared header types and a prim-\nitive set of actions.\nWe could use a language such as Click [10], which builds\nswitches from modules composed of arbitrary C++. Click is\nextremely expressive, and very suitable for expressing how\npackets are processed in the kernel of a CPU. But it is in-\nsu\u000eciently constrained for our needs|we need a language\nthat mirrors the parse-match-action pipelines in dedicated\nhardware. In addition, Click is not designed for a controller-\nswitch architecture and hence does not allow programmers\nto describe match +action tables that are dynamically pop-\nulated by well-typed rules. Finally, Click makes it di\u000ecult\nto infer dependencies that constrain parallel execution|as\nwe now discuss.\nA packet processing language must allow the programmer\nto express (implicitly or explicitly) any serial dependencies\nbetween header \felds. Dependencies determine which ta-\nbles can be executed in parallel. For example, sequential\nexecution is required for an IP routing table and an ARP\ntable due to the data dependency between them. Dependen-\ncies can be identi\fed by analyzing Table Dependency Graphs\n(TDGs); these graphs describe the \feld inputs, actions, and\ncontrol \row between tables. Figure 3 shows an example ta-\nble dependency graph for an L2/L3 switch. TDG nodes map\ndirectly to match +action tables, and a dependency analy-\nsis identi\fes where each table may reside in the pipeline.\nUnfortunately TDGs are not readily accessible to most pro-\ngrammers; programmers tend to think of packet processing\nalgorithms using imperative constructs rather than graphs.\nFigure 3: Table dependency graph for an L2/L3\nswitch.\nThis leads us to propose a two-step compilation process.\nAt the highest level, programmers express packet process-\ning programs using an imperative language representing the\ncontrol \row (P4); below this, a compiler translates the P4\nrepresentation to TDGs to facilitate dependency analysis,\nACM SIGCOMM Computer Communication Review\n90\nVolume 44, Number 3, July 2014\n<physical_index_3>\n<physical_index_4>\nand then maps the TDG to a speci\fc switch target. P4 is\ndesigned to make it easy to translate a P4 program into a\nTDG. In summary, P4 can be considered to be a sweet spot\nbetween the generality of say Click (that makes it di\u000ecult to\ninfer dependencies and map to hardware) and the in\rexibil-\nity of OpenFlow 1.0 (that makes it impossible to recon\fgure\nprotocol processing).\n4. P4 LANGUAGE BY EXAMPLE\nWe explore P4 by examining a simple example in-depth.\nMany network deployments di\u000berentiate between an edge\nand a core; end-hosts are directly connected to edge de-\nvices, which are in turn interconnected by a high-bandwidth\ncore. Entire protocols have been designed to support this\narchitecture (such as MPLS [11] and PortLand [12]), aimed\nprimarily at simplifying forwarding in the core.\nConsider an example L2 network deployment with top-\nof-rack (ToR) switches at the edge connected by a two-tier\ncore. We will assume the number of end-hosts is growing\nand the core L2 tables are over\rowing. MPLS is an option\nto simplify the core, but implementing a label distribution\nprotocol with multiple tags is a daunting task. PortLand\nlooks interesting but requires rewriting MAC addresses|\npossibly breaking existing network debugging tools|and re-\nquires new agents to respond to ARP requests.\nP4 lets us express a custom solution with minimal changes\nto the network architecture. We call our toy example mTag :\nit combines the hierarchical routing of PortLand with simple\nMPLS-like tags. The routes through the core are encoded\nby a 32-bit tag composed of four single-byte \felds. The 32-\nbit tag can carry a \\source route\" or a destination locator\n(like PortLand's Pseudo MAC). Each core switch need only\nexamine one byte of the tag and switch on that information.\nIn our example, the tag is added by the \frst ToR switch,\nalthough it could also be added by the end-host NIC.\nThe mTag example is intentionally very simple to focus\nour attention on the P4 language. The P4 program for an\nentire switch would be many times more complex in practice.\n4.1 P4 Concepts\nA P4 program contains de\fnitions of the following key\ncomponents:\n\u000fHeaders: A header de\fnition describes the sequence and\nstructure of a series of \felds. It includes speci\fcation of\n\feld widths and constraints on \feld values.\n\u000fParsers: A parser de\fnition speci\fes how to identify\nheaders and valid header sequences within packets.\n\u000fTables: Match +action tables are the mechanism for per-\nforming packet processing. The P4 program de\fnes the\n\felds on which a table may match and the actions it may\nexecute.\n\u000fActions: P4 supports construction of complex actions\nfrom simpler protocol-independent primitives. These com-\nplex actions are available within match +action tables.\u000fControl Programs: The control program determines\nthe order of match +action tables that are applied to a\npacket. A simple imperative program describe the \row of\ncontrol between match +action tables.\nNext, we show how each of these components contributes to\nthe de\fnition of an idealized mTag processor in P4.\n4.2 Header Formats\nA design begins with the speci\fcation of header formats.\nSeveral domain-speci\fc languages have been proposed for\nthis [13, 14, 15]; P4 borrows a number of ideas from them.\nIn general, each header is speci\fed by declaring an ordered\nlist of \feld names together with their widths. Optional \feld\nannotations allow constraints on value ranges or maximum\nlengths for variable-sized \felds. For example, standard Eth-\nernet and VLAN headers are speci\fed as follows:\nheader ethernet {\nfields {\ndst_addr : 48; // width in bits\nsrc_addr : 48;\nethertype : 16;\n}\n}\nheader vlan {\nfields {\npcp : 3;\ncfi : 1;\nvid : 12;\nethertype : 16;\n}\n}\nThe mTag header can be added without altering existing\ndeclarations. The \feld names indicate that the core has\ntwo layers of aggregation. Each core switch is programmed\nwith rules to examine one of these bytes determined by its\nlocation in the hierarchy and the direction of travel (up or\ndown).\nheader mTag {\nfields {\nup1 : 8;\nup2 : 8;\ndown1 : 8;\ndown2 : 8;\nethertype : 16;\n}\n}\n4.3 The Packet Parser\nP4 assumes the underlying switch can implement a state\nmachine that traverses packet headers from start to \fnish,\nextracting \feld values as it goes. The extracted \feld values\nare sent to the match +action tables for processing.\nP4 describes this state machine directly as the set of tran-\nsitions from one header to the next. Each transition may be\ntriggered by values in the current header. For example, we\ndescribe the mTag state machine as follows.\nACM SIGCOMM Computer Communication Review\n91\nVolume 44, Number 3, July 2014\n<physical_index_4>\n<physical_index_5>\nparser start {\nethernet;\n}\nparser ethernet {\nswitch(ethertype) {\ncase 0x8100: vlan;\ncase 0x9100: vlan;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser vlan {\nswitch(ethertype) {\ncase 0xaaaa: mTag;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser mTag {\nswitch(ethertype) {\ncase 0x800: ipv4;\n// Other cases\n}\n}\nParsing starts in the start state and proceeds until an\nexplicit stop state is reached or an unhandled case is en-\ncountered (which may be marked as an error). Upon reach-\ning a state for a new header, the state machine extracts\nthe header using its speci\fcation and proceeds to identify\nits next transition. The extracted headers are forwarded\nto match +action processing in the back-half of the switch\npipeline.\nThe parser for mTag is very simple: it has only four states.\nParsers in real networks require many more states; for ex-\nample, the parser de\fned by Gibb et. al. [16, Figure 3(e)]\nexpands to over one hundred states.\n4.4 Table Speci\ufb01cation\nNext, the programmer describes how the de\fned header\n\felds are to be matched in the match +action stages (e.g.,\nshould they be exact matches, ranges, or wildcards?) and\nwhat actions should be performed when a match occurs.\nIn our simple mTag example, the edge switch matches on\nthe L2 destination and VLAN ID, and selects an mTag to\nadd to the header. The programmer de\fnes a table to match\non these \felds and apply an action to add the mTag header\n(see below). The reads attribute declares which \felds to\nmatch, quali\fed by the match type (exact, ternary, etc).\nThe actions attribute lists the possible actions which may\nbe applied to a packet by the table. Actions are explained in\nthe following section. The maxsize attribute speci\fes how\nmany entries the table should support.\nThe table speci\fcation allows a compiler to decide how\nmuch memory it needs, and the memory type (e.g., TCAM\nor SRAM) to implement the table.table mTag_table {\nreads {\nethernet.dst_addr : exact;\nvlan.vid : exact;\n}\nactions {\n// At runtime, entries are programmed with params\n// for the mTag action. See below.\nadd_mTag;\n}\nmax_size : 20000;\n}\nFor completeness and for later discussion, we present brief\nde\fnitions of other tables that are referenced by the Control\nProgram (x4.6).\ntable source_check {\n// Verify mtag only on ports to the core\nreads {\nmtag : valid; // Was mtag parsed?\nmetadata.ingress_port : exact;\n}\nactions { // Each table entry specifies *one* action\n// If inappropriate mTag, send to CPU\nfault_to_cpu;\n// If mtag found, strip and record in metadata\nstrip_mtag;\n// Otherwise, allow the packet to continue\npass;\n}\nmax_size : 64; // One rule per port\n}\ntable local_switching {\n// Reads destination and checks if local\n// If miss occurs, goto mtag table.\n}\ntable egress_check {\n// Verify egress is resolved\n// Do not retag packets received with tag\n// Reads egress and whether packet was mTagged\n}\n4.5 Action Speci\ufb01cations\nP4 de\fnes a collection of primitive actions from which\nmore complicated actions are built. Each P4 program de-\nclares a set of action functions that are composed of action\nprimitives; these action functions simplify table speci\fcation\nand population. P4 assumes parallel execution of primitives\nwithin an action function. (Switches incapable of parallel\nexecution may emulate the semantics.)\nThe addmTag action referred to above is implemented as\nfollows:\naction add_mTag(up1, up2, down1, down2, egr_spec) {\nadd_header(mTag);\n// Copy VLAN ethertype to mTag\nACM SIGCOMM Computer Communication Review\n92\nVolume 44, Number 3, July 2014\n<physical_index_5>\n"
        },
        {
          "title": "4. P4 LANGUAGE BY EXAMPLE",
          "start_index": 5,
          "end_index": 7,
          "node_id": "0005",
          "text": "<physical_index_5>\nparser start {\nethernet;\n}\nparser ethernet {\nswitch(ethertype) {\ncase 0x8100: vlan;\ncase 0x9100: vlan;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser vlan {\nswitch(ethertype) {\ncase 0xaaaa: mTag;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser mTag {\nswitch(ethertype) {\ncase 0x800: ipv4;\n// Other cases\n}\n}\nParsing starts in the start state and proceeds until an\nexplicit stop state is reached or an unhandled case is en-\ncountered (which may be marked as an error). Upon reach-\ning a state for a new header, the state machine extracts\nthe header using its speci\fcation and proceeds to identify\nits next transition. The extracted headers are forwarded\nto match +action processing in the back-half of the switch\npipeline.\nThe parser for mTag is very simple: it has only four states.\nParsers in real networks require many more states; for ex-\nample, the parser de\fned by Gibb et. al. [16, Figure 3(e)]\nexpands to over one hundred states.\n4.4 Table Speci\ufb01cation\nNext, the programmer describes how the de\fned header\n\felds are to be matched in the match +action stages (e.g.,\nshould they be exact matches, ranges, or wildcards?) and\nwhat actions should be performed when a match occurs.\nIn our simple mTag example, the edge switch matches on\nthe L2 destination and VLAN ID, and selects an mTag to\nadd to the header. The programmer de\fnes a table to match\non these \felds and apply an action to add the mTag header\n(see below). The reads attribute declares which \felds to\nmatch, quali\fed by the match type (exact, ternary, etc).\nThe actions attribute lists the possible actions which may\nbe applied to a packet by the table. Actions are explained in\nthe following section. The maxsize attribute speci\fes how\nmany entries the table should support.\nThe table speci\fcation allows a compiler to decide how\nmuch memory it needs, and the memory type (e.g., TCAM\nor SRAM) to implement the table.table mTag_table {\nreads {\nethernet.dst_addr : exact;\nvlan.vid : exact;\n}\nactions {\n// At runtime, entries are programmed with params\n// for the mTag action. See below.\nadd_mTag;\n}\nmax_size : 20000;\n}\nFor completeness and for later discussion, we present brief\nde\fnitions of other tables that are referenced by the Control\nProgram (x4.6).\ntable source_check {\n// Verify mtag only on ports to the core\nreads {\nmtag : valid; // Was mtag parsed?\nmetadata.ingress_port : exact;\n}\nactions { // Each table entry specifies *one* action\n// If inappropriate mTag, send to CPU\nfault_to_cpu;\n// If mtag found, strip and record in metadata\nstrip_mtag;\n// Otherwise, allow the packet to continue\npass;\n}\nmax_size : 64; // One rule per port\n}\ntable local_switching {\n// Reads destination and checks if local\n// If miss occurs, goto mtag table.\n}\ntable egress_check {\n// Verify egress is resolved\n// Do not retag packets received with tag\n// Reads egress and whether packet was mTagged\n}\n4.5 Action Speci\ufb01cations\nP4 de\fnes a collection of primitive actions from which\nmore complicated actions are built. Each P4 program de-\nclares a set of action functions that are composed of action\nprimitives; these action functions simplify table speci\fcation\nand population. P4 assumes parallel execution of primitives\nwithin an action function. (Switches incapable of parallel\nexecution may emulate the semantics.)\nThe addmTag action referred to above is implemented as\nfollows:\naction add_mTag(up1, up2, down1, down2, egr_spec) {\nadd_header(mTag);\n// Copy VLAN ethertype to mTag\nACM SIGCOMM Computer Communication Review\n92\nVolume 44, Number 3, July 2014\n<physical_index_5>\n<physical_index_6>\ncopy_field(mTag.ethertype, vlan.ethertype);\n// Set VLAN's ethertype to signal mTag\nset_field(vlan.ethertype, 0xaaaa);\nset_field(mTag.up1, up1);\nset_field(mTag.up2, up2);\nset_field(mTag.down1, down1);\nset_field(mTag.down2, down2);\n// Set the destination egress port as well\nset_field(metadata.egress_spec, egr_spec);\n}\nIf an action needs parameters (e.g., the up1value for the\nmTag), it is supplied from the match table at runtime.\nIn this example, the switch inserts the mTag after the\nVLAN tag, copies the VLAN tag's Ethertype into the mTag\nto indicate what follows, and sets the VLAN tag's Ethertype\nto0xaaaa to signal mTag. Not shown are the inverse action\nspeci\fcation that strips an mTag from a packet and the table\nto apply this action in edge switches.\nP4's primitive actions include:\n\u000fsetfield: Set a speci\fc \feld in a header to a value.\nMasked sets are supported.\n\u000fcopy field: Copy one \feld to another.\n\u000faddheader: Set a speci\fc header instance (and all its\n\felds) as valid.\n\u000fremove header: Delete (\\pop\") a header (and all its \felds)\nfrom a packet.\n\u000fincrement: Increment or decrement the value in a \feld.\n\u000fchecksum: Calculate a checksum over some set of header\n\felds (e.g., an IPv4 checksum).\nWe expect most switch implementations will restrict action\nprocessing to permit only header modi\fcations that are con-\nsistent with the speci\fed packet format.\n4.6 The Control Program\nOnce tables and actions are de\fned, the only remaining\ntask is to specify the \row of control from one table to the\nnext. Control \row is speci\fed as a program via a collection\nof functions, conditionals, and table references.\nFigure 4: Flow chart for the mTag example.\nFigure 4 shows a graphical representation of the desired\ncontrol \row for the mTag implementation on edge switches.\nAfter parsing, the source check table veri\fes consistency\nbetween the received packet and the ingress port. For ex-\nample, mTags should only be seen on ports connected to\ncore switches. The source check also strips mTags fromthe packet, recording whether the packet had an mTag in\nmetadata. Tables later in the pipeline may match on this\nmetadata to avoid retagging the packet.\nThe local switching table is then executed. If this table\n\\misses,\" it indicates that the packet is not destined for a\nlocally connected host. In that case, the mTag table (de-\n\fned above) is applied to the packet. Both local and core\nforwarding control can be processed by the egress check\ntable which handles the case of an unknown destination by\nsending a noti\fcation up the SDN control stack.\nThe imperative representation of this packet processing\npipeline is as follows:\ncontrol main() {\n// Verify mTag state and port are consistent\ntable(source_check);\n// If no error from source_check, continue\nif (!defined(metadata.ingress_error)) {\n// Attempt to switch to end hosts\ntable(local_switching);\nif (!defined(metadata.egress_spec)) {\n// Not a known local host; try mtagging\ntable(mTag_table);\n}\n// Check for unknown egress state or\n// bad retagging with mTag.\ntable(egress_check);\n}\n}\n5. COMPILING A P4 PROGRAM\nFor a network to implement our P4 program, we need\na compiler to map the target-independent description onto\nthe target switch's speci\fc hardware or software platform.\nDoing so involves allocating the target's resources and gen-\nerating appropriate con\fguration for the device.\n5.1 Compiling Packet Parsers\nFor devices with programmable parsers, the compiler trans-\nlates the parser description into a parsing state machine,\nwhile for \fxed parsers, the compiler merely veri\fes that the\nparser description is consistent with the target's parser. De-\ntails of generating a state machine and state table entries\ncan be found in [16].\nTable 2 shows state table entries for the vlan and mTag\nsections of the parser ( x4.3). Each entry speci\fes the current\nstate, the \feld value to match, and the next state. Other\ncolumns are omitted for brevity.\nCurrent State Lookup Value Next State\nvlan 0xaaaa mTag\nvlan 0x800 ipv4\nvlan * stop\nmTag 0x800 ipv4\nmTag * stop\nTable 2: Parser state table entries for the mTag example.\nACM SIGCOMM Computer Communication Review\n93\nVolume 44, Number 3, July 2014\n<physical_index_6>\n<physical_index_7>\n5.2 Compiling Control Programs\nThe imperative control-\row representation in x4.6 is a\nconvenient way to specify the logical forwarding behavior of\na switch, but does not explicitly call out dependencies be-\ntween tables or opportunities for concurrency. We therefore\nemploy a compiler to analyze the control program to identify\ndependencies and look for opportunities to process header\n\felds in parallel. Finally, the compiler generates the tar-\nget con\fguration for the switch. There are many potential\ntargets: for example, a software switch [17], a multicore soft-\nware switch [18], an NPU [19], a \fxed function switch [20],\nor a recon\fgurable match table (RMT) pipeline [2].\nAs discussed inx3, the compiler follows a two-stage com-\npilation process. It \frst converts the P4 control program\ninto an intermediate table dependency graph representation\nwhich it analyzes to determine dependencies between ta-\nbles. A target-speci\fc back-end then maps this graph onto\nthe switch's speci\fc resources.\nWe brie\ry examine how the mTag example would be im-\nplemented in di\u000berent kinds of switches:\nSoftware switches: A software switch provides complete\n\rexibility: the table count, table con\fguration, and parsing\nare under software control. The compiler directly maps the\nmTag table graph to switch tables. The compiler uses ta-\nble type information to constrain table widths, heights, and\nmatching criterion (e.g., exact, pre\fx, or wildcard) of each\ntable. The compiler might also optimize ternary or pre\fx\nmatching with software data structures.\nHardware switches with RAM and TCAM: A com-\npiler can con\fgure hashing to perform e\u000ecient exact-match-\ning using RAM, for the mTag table in edge switches. In\ncontrast, the core mTag forwarding table that matches on a\nsubset of tag bits would be mapped to TCAM.\nSwitches supporting parallel tables: The compiler\ncan detect data dependencies and arrange tables in parallel\nor in series. In the mTag example, the tables mTag table and\nlocal switching can execute in parallel up to the execution\nof the action of setting an mTag.\nSwitches that apply actions at the end of the pipe-\nline: For switches with action processing only at the end of\na pipeline, the compiler can tell intermediate stages to gen-\nerate metadata that is used to perform the \fnal writes. In\nthe mTag example, whether the mTag is added or removed\ncould be represented in metadata.\nSwitches with a few tables: The compiler can map\na large number of P4 tables to a smaller number of physi-\ncal tables. In the mTag example, the local switching could\nbe combined with the mTag table. When the controller in-\nstalls new rules at runtime, the compiler's rule translator\ncan \\compose\" the rules in the two P4 tables to generate\nthe rules for the single physical table.\n6. CONCLUSION\nThe promise of SDN is that a single control plane can di-rectly control a whole network of switches. OpenFlow sup-\nports this goal by providing a single, vendor-agnostic API.\nHowever, today's OpenFlow targets \fxed-function switches\nthat recognize a predetermined set of header \felds and that\nprocess packets using a small set of prede\fned actions. The\ncontrol plane cannot express how packets should be pro-\ncessed to best meet the needs of control applications.\nWe propose a step towards more \rexible switches whose\nfunctionality is speci\fed|and may be changed|in the \feld.\nThe programmer decides how the forwarding plane processes\npackets without worrying about implementation details. A\ncompiler transforms an imperative program into a table de-\npendency graph that can be mapped to many speci\fc target\nswitches, including optimized hardware implementations.\nWe emphasize that this is only a \frst step, designed as\na straw-man proposal for OpenFlow 2.0 to contribute to\nthe debate. In this proposal, several aspects of a switch re-\nmain unde\fned (e.g., congestion-control primitives, queuing\ndisciplines, tra\u000ec monitoring). However, we believe the ap-\nproach of having a con\fguration language|and compilers\nthat generate low-level con\fgurations for speci\fc targets|\nwill lead to future switches that provide greater \rexibility,\nand unlock the potential of software de\fned networks.\n7. REFERENCES\n[1] C. Kozanitis, J. Huber, S. Singh, and G. Varghese,\n\\Leaping multiple headers in a single bound:\nWire-speed parsing using the Kangaroo system,\" in\nIEEE INFOCOM , pp. 830{838, 2010.\n[2] P. Bosshart, G. Gibb, H.-S. Kim, G. Varghese,\nN. McKeown, M. Izzard, F. Mujica, and M. Horowitz,\n\\Forwarding metamorphosis: Fast programmable\nmatch-action processing in hardware for SDN,\" in\nACM SIGCOMM, 2013.\n[3] \\Intel Ethernet Switch Silicon FM6000.\"\nhttp://www.intel.com/content/dam/www/public/\nus/en/documents/white-papers/ethernet-switch-\nfm6000-sdn-paper.pdf.\n[4] N. Yadav and D. Cohn, \\OpenFlow Primitive Set.\"\nhttp://goo.gl/6qwbg, July 2011.\n[5] H. Song, \\Protocol-oblivious forwarding: Unleash the\npower of SDN through a future-proof forwarding\nplane,\" in SIGCOMM HotSDN Workshop , Aug. 2013.\n[6] \\Open\row forwarding abstractions working group\ncharter.\" http://goo.gl/TtLtw0, Apr. 2013.\n[7] M. Raju, A. Wundsam, and M. Yu, \\NOSIX: A\nlightweight portability layer for the SDN OS,\" ACM\nSIGCOMM Computer Communications Review, 2014.\n[8] V. Jeyakumar, M. Alizadeh, C. Kim, and D. Mazieres,\n\\Tiny packet programs for low-latency network\ncontrol and monitoring,\" in ACM SIGCOMM HotNets\nWorkshop, Nov. 2013.\n[9] A. Sivaraman, K. Winstein, S. Subramanian, and\nH. Balakrishnan, \\No silver bullet: Extending SDN to\nACM SIGCOMM Computer Communication Review\n94\nVolume 44, Number 3, July 2014\n<physical_index_7>\n"
        },
        {
          "title": "4.1 P4 Concepts",
          "start_index": 7,
          "end_index": 7,
          "node_id": "0006",
          "text": "<physical_index_7>\n5.2 Compiling Control Programs\nThe imperative control-\row representation in x4.6 is a\nconvenient way to specify the logical forwarding behavior of\na switch, but does not explicitly call out dependencies be-\ntween tables or opportunities for concurrency. We therefore\nemploy a compiler to analyze the control program to identify\ndependencies and look for opportunities to process header\n\felds in parallel. Finally, the compiler generates the tar-\nget con\fguration for the switch. There are many potential\ntargets: for example, a software switch [17], a multicore soft-\nware switch [18], an NPU [19], a \fxed function switch [20],\nor a recon\fgurable match table (RMT) pipeline [2].\nAs discussed inx3, the compiler follows a two-stage com-\npilation process. It \frst converts the P4 control program\ninto an intermediate table dependency graph representation\nwhich it analyzes to determine dependencies between ta-\nbles. A target-speci\fc back-end then maps this graph onto\nthe switch's speci\fc resources.\nWe brie\ry examine how the mTag example would be im-\nplemented in di\u000berent kinds of switches:\nSoftware switches: A software switch provides complete\n\rexibility: the table count, table con\fguration, and parsing\nare under software control. The compiler directly maps the\nmTag table graph to switch tables. The compiler uses ta-\nble type information to constrain table widths, heights, and\nmatching criterion (e.g., exact, pre\fx, or wildcard) of each\ntable. The compiler might also optimize ternary or pre\fx\nmatching with software data structures.\nHardware switches with RAM and TCAM: A com-\npiler can con\fgure hashing to perform e\u000ecient exact-match-\ning using RAM, for the mTag table in edge switches. In\ncontrast, the core mTag forwarding table that matches on a\nsubset of tag bits would be mapped to TCAM.\nSwitches supporting parallel tables: The compiler\ncan detect data dependencies and arrange tables in parallel\nor in series. In the mTag example, the tables mTag table and\nlocal switching can execute in parallel up to the execution\nof the action of setting an mTag.\nSwitches that apply actions at the end of the pipe-\nline: For switches with action processing only at the end of\na pipeline, the compiler can tell intermediate stages to gen-\nerate metadata that is used to perform the \fnal writes. In\nthe mTag example, whether the mTag is added or removed\ncould be represented in metadata.\nSwitches with a few tables: The compiler can map\na large number of P4 tables to a smaller number of physi-\ncal tables. In the mTag example, the local switching could\nbe combined with the mTag table. When the controller in-\nstalls new rules at runtime, the compiler's rule translator\ncan \\compose\" the rules in the two P4 tables to generate\nthe rules for the single physical table.\n6. CONCLUSION\nThe promise of SDN is that a single control plane can di-rectly control a whole network of switches. OpenFlow sup-\nports this goal by providing a single, vendor-agnostic API.\nHowever, today's OpenFlow targets \fxed-function switches\nthat recognize a predetermined set of header \felds and that\nprocess packets using a small set of prede\fned actions. The\ncontrol plane cannot express how packets should be pro-\ncessed to best meet the needs of control applications.\nWe propose a step towards more \rexible switches whose\nfunctionality is speci\fed|and may be changed|in the \feld.\nThe programmer decides how the forwarding plane processes\npackets without worrying about implementation details. A\ncompiler transforms an imperative program into a table de-\npendency graph that can be mapped to many speci\fc target\nswitches, including optimized hardware implementations.\nWe emphasize that this is only a \frst step, designed as\na straw-man proposal for OpenFlow 2.0 to contribute to\nthe debate. In this proposal, several aspects of a switch re-\nmain unde\fned (e.g., congestion-control primitives, queuing\ndisciplines, tra\u000ec monitoring). However, we believe the ap-\nproach of having a con\fguration language|and compilers\nthat generate low-level con\fgurations for speci\fc targets|\nwill lead to future switches that provide greater \rexibility,\nand unlock the potential of software de\fned networks.\n7. REFERENCES\n[1] C. Kozanitis, J. Huber, S. Singh, and G. Varghese,\n\\Leaping multiple headers in a single bound:\nWire-speed parsing using the Kangaroo system,\" in\nIEEE INFOCOM , pp. 830{838, 2010.\n[2] P. Bosshart, G. Gibb, H.-S. Kim, G. Varghese,\nN. McKeown, M. Izzard, F. Mujica, and M. Horowitz,\n\\Forwarding metamorphosis: Fast programmable\nmatch-action processing in hardware for SDN,\" in\nACM SIGCOMM, 2013.\n[3] \\Intel Ethernet Switch Silicon FM6000.\"\nhttp://www.intel.com/content/dam/www/public/\nus/en/documents/white-papers/ethernet-switch-\nfm6000-sdn-paper.pdf.\n[4] N. Yadav and D. Cohn, \\OpenFlow Primitive Set.\"\nhttp://goo.gl/6qwbg, July 2011.\n[5] H. Song, \\Protocol-oblivious forwarding: Unleash the\npower of SDN through a future-proof forwarding\nplane,\" in SIGCOMM HotSDN Workshop , Aug. 2013.\n[6] \\Open\row forwarding abstractions working group\ncharter.\" http://goo.gl/TtLtw0, Apr. 2013.\n[7] M. Raju, A. Wundsam, and M. Yu, \\NOSIX: A\nlightweight portability layer for the SDN OS,\" ACM\nSIGCOMM Computer Communications Review, 2014.\n[8] V. Jeyakumar, M. Alizadeh, C. Kim, and D. Mazieres,\n\\Tiny packet programs for low-latency network\ncontrol and monitoring,\" in ACM SIGCOMM HotNets\nWorkshop, Nov. 2013.\n[9] A. Sivaraman, K. Winstein, S. Subramanian, and\nH. Balakrishnan, \\No silver bullet: Extending SDN to\nACM SIGCOMM Computer Communication Review\n94\nVolume 44, Number 3, July 2014\n<physical_index_7>\n"
        },
        {
          "title": "4.2 Header Formats",
          "start_index": 7,
          "end_index": 4,
          "node_id": "0007",
          "text": ""
        },
        {
          "title": "4.3 The Packet Parser",
          "start_index": 4,
          "end_index": 4,
          "node_id": "0008",
          "text": "<physical_index_4>\nand then maps the TDG to a speci\fc switch target. P4 is\ndesigned to make it easy to translate a P4 program into a\nTDG. In summary, P4 can be considered to be a sweet spot\nbetween the generality of say Click (that makes it di\u000ecult to\ninfer dependencies and map to hardware) and the in\rexibil-\nity of OpenFlow 1.0 (that makes it impossible to recon\fgure\nprotocol processing).\n4. P4 LANGUAGE BY EXAMPLE\nWe explore P4 by examining a simple example in-depth.\nMany network deployments di\u000berentiate between an edge\nand a core; end-hosts are directly connected to edge de-\nvices, which are in turn interconnected by a high-bandwidth\ncore. Entire protocols have been designed to support this\narchitecture (such as MPLS [11] and PortLand [12]), aimed\nprimarily at simplifying forwarding in the core.\nConsider an example L2 network deployment with top-\nof-rack (ToR) switches at the edge connected by a two-tier\ncore. We will assume the number of end-hosts is growing\nand the core L2 tables are over\rowing. MPLS is an option\nto simplify the core, but implementing a label distribution\nprotocol with multiple tags is a daunting task. PortLand\nlooks interesting but requires rewriting MAC addresses|\npossibly breaking existing network debugging tools|and re-\nquires new agents to respond to ARP requests.\nP4 lets us express a custom solution with minimal changes\nto the network architecture. We call our toy example mTag :\nit combines the hierarchical routing of PortLand with simple\nMPLS-like tags. The routes through the core are encoded\nby a 32-bit tag composed of four single-byte \felds. The 32-\nbit tag can carry a \\source route\" or a destination locator\n(like PortLand's Pseudo MAC). Each core switch need only\nexamine one byte of the tag and switch on that information.\nIn our example, the tag is added by the \frst ToR switch,\nalthough it could also be added by the end-host NIC.\nThe mTag example is intentionally very simple to focus\nour attention on the P4 language. The P4 program for an\nentire switch would be many times more complex in practice.\n4.1 P4 Concepts\nA P4 program contains de\fnitions of the following key\ncomponents:\n\u000fHeaders: A header de\fnition describes the sequence and\nstructure of a series of \felds. It includes speci\fcation of\n\feld widths and constraints on \feld values.\n\u000fParsers: A parser de\fnition speci\fes how to identify\nheaders and valid header sequences within packets.\n\u000fTables: Match +action tables are the mechanism for per-\nforming packet processing. The P4 program de\fnes the\n\felds on which a table may match and the actions it may\nexecute.\n\u000fActions: P4 supports construction of complex actions\nfrom simpler protocol-independent primitives. These com-\nplex actions are available within match +action tables.\u000fControl Programs: The control program determines\nthe order of match +action tables that are applied to a\npacket. A simple imperative program describe the \row of\ncontrol between match +action tables.\nNext, we show how each of these components contributes to\nthe de\fnition of an idealized mTag processor in P4.\n4.2 Header Formats\nA design begins with the speci\fcation of header formats.\nSeveral domain-speci\fc languages have been proposed for\nthis [13, 14, 15]; P4 borrows a number of ideas from them.\nIn general, each header is speci\fed by declaring an ordered\nlist of \feld names together with their widths. Optional \feld\nannotations allow constraints on value ranges or maximum\nlengths for variable-sized \felds. For example, standard Eth-\nernet and VLAN headers are speci\fed as follows:\nheader ethernet {\nfields {\ndst_addr : 48; // width in bits\nsrc_addr : 48;\nethertype : 16;\n}\n}\nheader vlan {\nfields {\npcp : 3;\ncfi : 1;\nvid : 12;\nethertype : 16;\n}\n}\nThe mTag header can be added without altering existing\ndeclarations. The \feld names indicate that the core has\ntwo layers of aggregation. Each core switch is programmed\nwith rules to examine one of these bytes determined by its\nlocation in the hierarchy and the direction of travel (up or\ndown).\nheader mTag {\nfields {\nup1 : 8;\nup2 : 8;\ndown1 : 8;\ndown2 : 8;\nethertype : 16;\n}\n}\n4.3 The Packet Parser\nP4 assumes the underlying switch can implement a state\nmachine that traverses packet headers from start to \fnish,\nextracting \feld values as it goes. The extracted \feld values\nare sent to the match +action tables for processing.\nP4 describes this state machine directly as the set of tran-\nsitions from one header to the next. Each transition may be\ntriggered by values in the current header. For example, we\ndescribe the mTag state machine as follows.\nACM SIGCOMM Computer Communication Review\n91\nVolume 44, Number 3, July 2014\n<physical_index_4>\n"
        },
        {
          "title": "4.4 Table Speci\ufb01cation",
          "start_index": 4,
          "end_index": 5,
          "node_id": "0009",
          "text": "<physical_index_4>\nand then maps the TDG to a speci\fc switch target. P4 is\ndesigned to make it easy to translate a P4 program into a\nTDG. In summary, P4 can be considered to be a sweet spot\nbetween the generality of say Click (that makes it di\u000ecult to\ninfer dependencies and map to hardware) and the in\rexibil-\nity of OpenFlow 1.0 (that makes it impossible to recon\fgure\nprotocol processing).\n4. P4 LANGUAGE BY EXAMPLE\nWe explore P4 by examining a simple example in-depth.\nMany network deployments di\u000berentiate between an edge\nand a core; end-hosts are directly connected to edge de-\nvices, which are in turn interconnected by a high-bandwidth\ncore. Entire protocols have been designed to support this\narchitecture (such as MPLS [11] and PortLand [12]), aimed\nprimarily at simplifying forwarding in the core.\nConsider an example L2 network deployment with top-\nof-rack (ToR) switches at the edge connected by a two-tier\ncore. We will assume the number of end-hosts is growing\nand the core L2 tables are over\rowing. MPLS is an option\nto simplify the core, but implementing a label distribution\nprotocol with multiple tags is a daunting task. PortLand\nlooks interesting but requires rewriting MAC addresses|\npossibly breaking existing network debugging tools|and re-\nquires new agents to respond to ARP requests.\nP4 lets us express a custom solution with minimal changes\nto the network architecture. We call our toy example mTag :\nit combines the hierarchical routing of PortLand with simple\nMPLS-like tags. The routes through the core are encoded\nby a 32-bit tag composed of four single-byte \felds. The 32-\nbit tag can carry a \\source route\" or a destination locator\n(like PortLand's Pseudo MAC). Each core switch need only\nexamine one byte of the tag and switch on that information.\nIn our example, the tag is added by the \frst ToR switch,\nalthough it could also be added by the end-host NIC.\nThe mTag example is intentionally very simple to focus\nour attention on the P4 language. The P4 program for an\nentire switch would be many times more complex in practice.\n4.1 P4 Concepts\nA P4 program contains de\fnitions of the following key\ncomponents:\n\u000fHeaders: A header de\fnition describes the sequence and\nstructure of a series of \felds. It includes speci\fcation of\n\feld widths and constraints on \feld values.\n\u000fParsers: A parser de\fnition speci\fes how to identify\nheaders and valid header sequences within packets.\n\u000fTables: Match +action tables are the mechanism for per-\nforming packet processing. The P4 program de\fnes the\n\felds on which a table may match and the actions it may\nexecute.\n\u000fActions: P4 supports construction of complex actions\nfrom simpler protocol-independent primitives. These com-\nplex actions are available within match +action tables.\u000fControl Programs: The control program determines\nthe order of match +action tables that are applied to a\npacket. A simple imperative program describe the \row of\ncontrol between match +action tables.\nNext, we show how each of these components contributes to\nthe de\fnition of an idealized mTag processor in P4.\n4.2 Header Formats\nA design begins with the speci\fcation of header formats.\nSeveral domain-speci\fc languages have been proposed for\nthis [13, 14, 15]; P4 borrows a number of ideas from them.\nIn general, each header is speci\fed by declaring an ordered\nlist of \feld names together with their widths. Optional \feld\nannotations allow constraints on value ranges or maximum\nlengths for variable-sized \felds. For example, standard Eth-\nernet and VLAN headers are speci\fed as follows:\nheader ethernet {\nfields {\ndst_addr : 48; // width in bits\nsrc_addr : 48;\nethertype : 16;\n}\n}\nheader vlan {\nfields {\npcp : 3;\ncfi : 1;\nvid : 12;\nethertype : 16;\n}\n}\nThe mTag header can be added without altering existing\ndeclarations. The \feld names indicate that the core has\ntwo layers of aggregation. Each core switch is programmed\nwith rules to examine one of these bytes determined by its\nlocation in the hierarchy and the direction of travel (up or\ndown).\nheader mTag {\nfields {\nup1 : 8;\nup2 : 8;\ndown1 : 8;\ndown2 : 8;\nethertype : 16;\n}\n}\n4.3 The Packet Parser\nP4 assumes the underlying switch can implement a state\nmachine that traverses packet headers from start to \fnish,\nextracting \feld values as it goes. The extracted \feld values\nare sent to the match +action tables for processing.\nP4 describes this state machine directly as the set of tran-\nsitions from one header to the next. Each transition may be\ntriggered by values in the current header. For example, we\ndescribe the mTag state machine as follows.\nACM SIGCOMM Computer Communication Review\n91\nVolume 44, Number 3, July 2014\n<physical_index_4>\n<physical_index_5>\nparser start {\nethernet;\n}\nparser ethernet {\nswitch(ethertype) {\ncase 0x8100: vlan;\ncase 0x9100: vlan;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser vlan {\nswitch(ethertype) {\ncase 0xaaaa: mTag;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser mTag {\nswitch(ethertype) {\ncase 0x800: ipv4;\n// Other cases\n}\n}\nParsing starts in the start state and proceeds until an\nexplicit stop state is reached or an unhandled case is en-\ncountered (which may be marked as an error). Upon reach-\ning a state for a new header, the state machine extracts\nthe header using its speci\fcation and proceeds to identify\nits next transition. The extracted headers are forwarded\nto match +action processing in the back-half of the switch\npipeline.\nThe parser for mTag is very simple: it has only four states.\nParsers in real networks require many more states; for ex-\nample, the parser de\fned by Gibb et. al. [16, Figure 3(e)]\nexpands to over one hundred states.\n4.4 Table Speci\ufb01cation\nNext, the programmer describes how the de\fned header\n\felds are to be matched in the match +action stages (e.g.,\nshould they be exact matches, ranges, or wildcards?) and\nwhat actions should be performed when a match occurs.\nIn our simple mTag example, the edge switch matches on\nthe L2 destination and VLAN ID, and selects an mTag to\nadd to the header. The programmer de\fnes a table to match\non these \felds and apply an action to add the mTag header\n(see below). The reads attribute declares which \felds to\nmatch, quali\fed by the match type (exact, ternary, etc).\nThe actions attribute lists the possible actions which may\nbe applied to a packet by the table. Actions are explained in\nthe following section. The maxsize attribute speci\fes how\nmany entries the table should support.\nThe table speci\fcation allows a compiler to decide how\nmuch memory it needs, and the memory type (e.g., TCAM\nor SRAM) to implement the table.table mTag_table {\nreads {\nethernet.dst_addr : exact;\nvlan.vid : exact;\n}\nactions {\n// At runtime, entries are programmed with params\n// for the mTag action. See below.\nadd_mTag;\n}\nmax_size : 20000;\n}\nFor completeness and for later discussion, we present brief\nde\fnitions of other tables that are referenced by the Control\nProgram (x4.6).\ntable source_check {\n// Verify mtag only on ports to the core\nreads {\nmtag : valid; // Was mtag parsed?\nmetadata.ingress_port : exact;\n}\nactions { // Each table entry specifies *one* action\n// If inappropriate mTag, send to CPU\nfault_to_cpu;\n// If mtag found, strip and record in metadata\nstrip_mtag;\n// Otherwise, allow the packet to continue\npass;\n}\nmax_size : 64; // One rule per port\n}\ntable local_switching {\n// Reads destination and checks if local\n// If miss occurs, goto mtag table.\n}\ntable egress_check {\n// Verify egress is resolved\n// Do not retag packets received with tag\n// Reads egress and whether packet was mTagged\n}\n4.5 Action Speci\ufb01cations\nP4 de\fnes a collection of primitive actions from which\nmore complicated actions are built. Each P4 program de-\nclares a set of action functions that are composed of action\nprimitives; these action functions simplify table speci\fcation\nand population. P4 assumes parallel execution of primitives\nwithin an action function. (Switches incapable of parallel\nexecution may emulate the semantics.)\nThe addmTag action referred to above is implemented as\nfollows:\naction add_mTag(up1, up2, down1, down2, egr_spec) {\nadd_header(mTag);\n// Copy VLAN ethertype to mTag\nACM SIGCOMM Computer Communication Review\n92\nVolume 44, Number 3, July 2014\n<physical_index_5>\n"
        },
        {
          "title": "4.5 Action Speci\ufb01cations",
          "start_index": 5,
          "end_index": 5,
          "node_id": "0010",
          "text": "<physical_index_5>\nparser start {\nethernet;\n}\nparser ethernet {\nswitch(ethertype) {\ncase 0x8100: vlan;\ncase 0x9100: vlan;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser vlan {\nswitch(ethertype) {\ncase 0xaaaa: mTag;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser mTag {\nswitch(ethertype) {\ncase 0x800: ipv4;\n// Other cases\n}\n}\nParsing starts in the start state and proceeds until an\nexplicit stop state is reached or an unhandled case is en-\ncountered (which may be marked as an error). Upon reach-\ning a state for a new header, the state machine extracts\nthe header using its speci\fcation and proceeds to identify\nits next transition. The extracted headers are forwarded\nto match +action processing in the back-half of the switch\npipeline.\nThe parser for mTag is very simple: it has only four states.\nParsers in real networks require many more states; for ex-\nample, the parser de\fned by Gibb et. al. [16, Figure 3(e)]\nexpands to over one hundred states.\n4.4 Table Speci\ufb01cation\nNext, the programmer describes how the de\fned header\n\felds are to be matched in the match +action stages (e.g.,\nshould they be exact matches, ranges, or wildcards?) and\nwhat actions should be performed when a match occurs.\nIn our simple mTag example, the edge switch matches on\nthe L2 destination and VLAN ID, and selects an mTag to\nadd to the header. The programmer de\fnes a table to match\non these \felds and apply an action to add the mTag header\n(see below). The reads attribute declares which \felds to\nmatch, quali\fed by the match type (exact, ternary, etc).\nThe actions attribute lists the possible actions which may\nbe applied to a packet by the table. Actions are explained in\nthe following section. The maxsize attribute speci\fes how\nmany entries the table should support.\nThe table speci\fcation allows a compiler to decide how\nmuch memory it needs, and the memory type (e.g., TCAM\nor SRAM) to implement the table.table mTag_table {\nreads {\nethernet.dst_addr : exact;\nvlan.vid : exact;\n}\nactions {\n// At runtime, entries are programmed with params\n// for the mTag action. See below.\nadd_mTag;\n}\nmax_size : 20000;\n}\nFor completeness and for later discussion, we present brief\nde\fnitions of other tables that are referenced by the Control\nProgram (x4.6).\ntable source_check {\n// Verify mtag only on ports to the core\nreads {\nmtag : valid; // Was mtag parsed?\nmetadata.ingress_port : exact;\n}\nactions { // Each table entry specifies *one* action\n// If inappropriate mTag, send to CPU\nfault_to_cpu;\n// If mtag found, strip and record in metadata\nstrip_mtag;\n// Otherwise, allow the packet to continue\npass;\n}\nmax_size : 64; // One rule per port\n}\ntable local_switching {\n// Reads destination and checks if local\n// If miss occurs, goto mtag table.\n}\ntable egress_check {\n// Verify egress is resolved\n// Do not retag packets received with tag\n// Reads egress and whether packet was mTagged\n}\n4.5 Action Speci\ufb01cations\nP4 de\fnes a collection of primitive actions from which\nmore complicated actions are built. Each P4 program de-\nclares a set of action functions that are composed of action\nprimitives; these action functions simplify table speci\fcation\nand population. P4 assumes parallel execution of primitives\nwithin an action function. (Switches incapable of parallel\nexecution may emulate the semantics.)\nThe addmTag action referred to above is implemented as\nfollows:\naction add_mTag(up1, up2, down1, down2, egr_spec) {\nadd_header(mTag);\n// Copy VLAN ethertype to mTag\nACM SIGCOMM Computer Communication Review\n92\nVolume 44, Number 3, July 2014\n<physical_index_5>\n"
        },
        {
          "title": "4.6 The Control Program",
          "start_index": 5,
          "end_index": 6,
          "node_id": "0011",
          "text": "<physical_index_5>\nparser start {\nethernet;\n}\nparser ethernet {\nswitch(ethertype) {\ncase 0x8100: vlan;\ncase 0x9100: vlan;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser vlan {\nswitch(ethertype) {\ncase 0xaaaa: mTag;\ncase 0x800: ipv4;\n// Other cases\n}\n}\nparser mTag {\nswitch(ethertype) {\ncase 0x800: ipv4;\n// Other cases\n}\n}\nParsing starts in the start state and proceeds until an\nexplicit stop state is reached or an unhandled case is en-\ncountered (which may be marked as an error). Upon reach-\ning a state for a new header, the state machine extracts\nthe header using its speci\fcation and proceeds to identify\nits next transition. The extracted headers are forwarded\nto match +action processing in the back-half of the switch\npipeline.\nThe parser for mTag is very simple: it has only four states.\nParsers in real networks require many more states; for ex-\nample, the parser de\fned by Gibb et. al. [16, Figure 3(e)]\nexpands to over one hundred states.\n4.4 Table Speci\ufb01cation\nNext, the programmer describes how the de\fned header\n\felds are to be matched in the match +action stages (e.g.,\nshould they be exact matches, ranges, or wildcards?) and\nwhat actions should be performed when a match occurs.\nIn our simple mTag example, the edge switch matches on\nthe L2 destination and VLAN ID, and selects an mTag to\nadd to the header. The programmer de\fnes a table to match\non these \felds and apply an action to add the mTag header\n(see below). The reads attribute declares which \felds to\nmatch, quali\fed by the match type (exact, ternary, etc).\nThe actions attribute lists the possible actions which may\nbe applied to a packet by the table. Actions are explained in\nthe following section. The maxsize attribute speci\fes how\nmany entries the table should support.\nThe table speci\fcation allows a compiler to decide how\nmuch memory it needs, and the memory type (e.g., TCAM\nor SRAM) to implement the table.table mTag_table {\nreads {\nethernet.dst_addr : exact;\nvlan.vid : exact;\n}\nactions {\n// At runtime, entries are programmed with params\n// for the mTag action. See below.\nadd_mTag;\n}\nmax_size : 20000;\n}\nFor completeness and for later discussion, we present brief\nde\fnitions of other tables that are referenced by the Control\nProgram (x4.6).\ntable source_check {\n// Verify mtag only on ports to the core\nreads {\nmtag : valid; // Was mtag parsed?\nmetadata.ingress_port : exact;\n}\nactions { // Each table entry specifies *one* action\n// If inappropriate mTag, send to CPU\nfault_to_cpu;\n// If mtag found, strip and record in metadata\nstrip_mtag;\n// Otherwise, allow the packet to continue\npass;\n}\nmax_size : 64; // One rule per port\n}\ntable local_switching {\n// Reads destination and checks if local\n// If miss occurs, goto mtag table.\n}\ntable egress_check {\n// Verify egress is resolved\n// Do not retag packets received with tag\n// Reads egress and whether packet was mTagged\n}\n4.5 Action Speci\ufb01cations\nP4 de\fnes a collection of primitive actions from which\nmore complicated actions are built. Each P4 program de-\nclares a set of action functions that are composed of action\nprimitives; these action functions simplify table speci\fcation\nand population. P4 assumes parallel execution of primitives\nwithin an action function. (Switches incapable of parallel\nexecution may emulate the semantics.)\nThe addmTag action referred to above is implemented as\nfollows:\naction add_mTag(up1, up2, down1, down2, egr_spec) {\nadd_header(mTag);\n// Copy VLAN ethertype to mTag\nACM SIGCOMM Computer Communication Review\n92\nVolume 44, Number 3, July 2014\n<physical_index_5>\n<physical_index_6>\ncopy_field(mTag.ethertype, vlan.ethertype);\n// Set VLAN's ethertype to signal mTag\nset_field(vlan.ethertype, 0xaaaa);\nset_field(mTag.up1, up1);\nset_field(mTag.up2, up2);\nset_field(mTag.down1, down1);\nset_field(mTag.down2, down2);\n// Set the destination egress port as well\nset_field(metadata.egress_spec, egr_spec);\n}\nIf an action needs parameters (e.g., the up1value for the\nmTag), it is supplied from the match table at runtime.\nIn this example, the switch inserts the mTag after the\nVLAN tag, copies the VLAN tag's Ethertype into the mTag\nto indicate what follows, and sets the VLAN tag's Ethertype\nto0xaaaa to signal mTag. Not shown are the inverse action\nspeci\fcation that strips an mTag from a packet and the table\nto apply this action in edge switches.\nP4's primitive actions include:\n\u000fsetfield: Set a speci\fc \feld in a header to a value.\nMasked sets are supported.\n\u000fcopy field: Copy one \feld to another.\n\u000faddheader: Set a speci\fc header instance (and all its\n\felds) as valid.\n\u000fremove header: Delete (\\pop\") a header (and all its \felds)\nfrom a packet.\n\u000fincrement: Increment or decrement the value in a \feld.\n\u000fchecksum: Calculate a checksum over some set of header\n\felds (e.g., an IPv4 checksum).\nWe expect most switch implementations will restrict action\nprocessing to permit only header modi\fcations that are con-\nsistent with the speci\fed packet format.\n4.6 The Control Program\nOnce tables and actions are de\fned, the only remaining\ntask is to specify the \row of control from one table to the\nnext. Control \row is speci\fed as a program via a collection\nof functions, conditionals, and table references.\nFigure 4: Flow chart for the mTag example.\nFigure 4 shows a graphical representation of the desired\ncontrol \row for the mTag implementation on edge switches.\nAfter parsing, the source check table veri\fes consistency\nbetween the received packet and the ingress port. For ex-\nample, mTags should only be seen on ports connected to\ncore switches. The source check also strips mTags fromthe packet, recording whether the packet had an mTag in\nmetadata. Tables later in the pipeline may match on this\nmetadata to avoid retagging the packet.\nThe local switching table is then executed. If this table\n\\misses,\" it indicates that the packet is not destined for a\nlocally connected host. In that case, the mTag table (de-\n\fned above) is applied to the packet. Both local and core\nforwarding control can be processed by the egress check\ntable which handles the case of an unknown destination by\nsending a noti\fcation up the SDN control stack.\nThe imperative representation of this packet processing\npipeline is as follows:\ncontrol main() {\n// Verify mTag state and port are consistent\ntable(source_check);\n// If no error from source_check, continue\nif (!defined(metadata.ingress_error)) {\n// Attempt to switch to end hosts\ntable(local_switching);\nif (!defined(metadata.egress_spec)) {\n// Not a known local host; try mtagging\ntable(mTag_table);\n}\n// Check for unknown egress state or\n// bad retagging with mTag.\ntable(egress_check);\n}\n}\n5. COMPILING A P4 PROGRAM\nFor a network to implement our P4 program, we need\na compiler to map the target-independent description onto\nthe target switch's speci\fc hardware or software platform.\nDoing so involves allocating the target's resources and gen-\nerating appropriate con\fguration for the device.\n5.1 Compiling Packet Parsers\nFor devices with programmable parsers, the compiler trans-\nlates the parser description into a parsing state machine,\nwhile for \fxed parsers, the compiler merely veri\fes that the\nparser description is consistent with the target's parser. De-\ntails of generating a state machine and state table entries\ncan be found in [16].\nTable 2 shows state table entries for the vlan and mTag\nsections of the parser ( x4.3). Each entry speci\fes the current\nstate, the \feld value to match, and the next state. Other\ncolumns are omitted for brevity.\nCurrent State Lookup Value Next State\nvlan 0xaaaa mTag\nvlan 0x800 ipv4\nvlan * stop\nmTag 0x800 ipv4\nmTag * stop\nTable 2: Parser state table entries for the mTag example.\nACM SIGCOMM Computer Communication Review\n93\nVolume 44, Number 3, July 2014\n<physical_index_6>\n"
        },
        {
          "title": "5. COMPILING A P4 PROGRAM",
          "start_index": 6,
          "end_index": 6,
          "node_id": "0012",
          "text": "<physical_index_6>\ncopy_field(mTag.ethertype, vlan.ethertype);\n// Set VLAN's ethertype to signal mTag\nset_field(vlan.ethertype, 0xaaaa);\nset_field(mTag.up1, up1);\nset_field(mTag.up2, up2);\nset_field(mTag.down1, down1);\nset_field(mTag.down2, down2);\n// Set the destination egress port as well\nset_field(metadata.egress_spec, egr_spec);\n}\nIf an action needs parameters (e.g., the up1value for the\nmTag), it is supplied from the match table at runtime.\nIn this example, the switch inserts the mTag after the\nVLAN tag, copies the VLAN tag's Ethertype into the mTag\nto indicate what follows, and sets the VLAN tag's Ethertype\nto0xaaaa to signal mTag. Not shown are the inverse action\nspeci\fcation that strips an mTag from a packet and the table\nto apply this action in edge switches.\nP4's primitive actions include:\n\u000fsetfield: Set a speci\fc \feld in a header to a value.\nMasked sets are supported.\n\u000fcopy field: Copy one \feld to another.\n\u000faddheader: Set a speci\fc header instance (and all its\n\felds) as valid.\n\u000fremove header: Delete (\\pop\") a header (and all its \felds)\nfrom a packet.\n\u000fincrement: Increment or decrement the value in a \feld.\n\u000fchecksum: Calculate a checksum over some set of header\n\felds (e.g., an IPv4 checksum).\nWe expect most switch implementations will restrict action\nprocessing to permit only header modi\fcations that are con-\nsistent with the speci\fed packet format.\n4.6 The Control Program\nOnce tables and actions are de\fned, the only remaining\ntask is to specify the \row of control from one table to the\nnext. Control \row is speci\fed as a program via a collection\nof functions, conditionals, and table references.\nFigure 4: Flow chart for the mTag example.\nFigure 4 shows a graphical representation of the desired\ncontrol \row for the mTag implementation on edge switches.\nAfter parsing, the source check table veri\fes consistency\nbetween the received packet and the ingress port. For ex-\nample, mTags should only be seen on ports connected to\ncore switches. The source check also strips mTags fromthe packet, recording whether the packet had an mTag in\nmetadata. Tables later in the pipeline may match on this\nmetadata to avoid retagging the packet.\nThe local switching table is then executed. If this table\n\\misses,\" it indicates that the packet is not destined for a\nlocally connected host. In that case, the mTag table (de-\n\fned above) is applied to the packet. Both local and core\nforwarding control can be processed by the egress check\ntable which handles the case of an unknown destination by\nsending a noti\fcation up the SDN control stack.\nThe imperative representation of this packet processing\npipeline is as follows:\ncontrol main() {\n// Verify mTag state and port are consistent\ntable(source_check);\n// If no error from source_check, continue\nif (!defined(metadata.ingress_error)) {\n// Attempt to switch to end hosts\ntable(local_switching);\nif (!defined(metadata.egress_spec)) {\n// Not a known local host; try mtagging\ntable(mTag_table);\n}\n// Check for unknown egress state or\n// bad retagging with mTag.\ntable(egress_check);\n}\n}\n5. COMPILING A P4 PROGRAM\nFor a network to implement our P4 program, we need\na compiler to map the target-independent description onto\nthe target switch's speci\fc hardware or software platform.\nDoing so involves allocating the target's resources and gen-\nerating appropriate con\fguration for the device.\n5.1 Compiling Packet Parsers\nFor devices with programmable parsers, the compiler trans-\nlates the parser description into a parsing state machine,\nwhile for \fxed parsers, the compiler merely veri\fes that the\nparser description is consistent with the target's parser. De-\ntails of generating a state machine and state table entries\ncan be found in [16].\nTable 2 shows state table entries for the vlan and mTag\nsections of the parser ( x4.3). Each entry speci\fes the current\nstate, the \feld value to match, and the next state. Other\ncolumns are omitted for brevity.\nCurrent State Lookup Value Next State\nvlan 0xaaaa mTag\nvlan 0x800 ipv4\nvlan * stop\nmTag 0x800 ipv4\nmTag * stop\nTable 2: Parser state table entries for the mTag example.\nACM SIGCOMM Computer Communication Review\n93\nVolume 44, Number 3, July 2014\n<physical_index_6>\n"
        },
        {
          "title": "5.1 Compiling Packet Parsers",
          "start_index": 6,
          "end_index": 6,
          "node_id": "0013",
          "text": "<physical_index_6>\ncopy_field(mTag.ethertype, vlan.ethertype);\n// Set VLAN's ethertype to signal mTag\nset_field(vlan.ethertype, 0xaaaa);\nset_field(mTag.up1, up1);\nset_field(mTag.up2, up2);\nset_field(mTag.down1, down1);\nset_field(mTag.down2, down2);\n// Set the destination egress port as well\nset_field(metadata.egress_spec, egr_spec);\n}\nIf an action needs parameters (e.g., the up1value for the\nmTag), it is supplied from the match table at runtime.\nIn this example, the switch inserts the mTag after the\nVLAN tag, copies the VLAN tag's Ethertype into the mTag\nto indicate what follows, and sets the VLAN tag's Ethertype\nto0xaaaa to signal mTag. Not shown are the inverse action\nspeci\fcation that strips an mTag from a packet and the table\nto apply this action in edge switches.\nP4's primitive actions include:\n\u000fsetfield: Set a speci\fc \feld in a header to a value.\nMasked sets are supported.\n\u000fcopy field: Copy one \feld to another.\n\u000faddheader: Set a speci\fc header instance (and all its\n\felds) as valid.\n\u000fremove header: Delete (\\pop\") a header (and all its \felds)\nfrom a packet.\n\u000fincrement: Increment or decrement the value in a \feld.\n\u000fchecksum: Calculate a checksum over some set of header\n\felds (e.g., an IPv4 checksum).\nWe expect most switch implementations will restrict action\nprocessing to permit only header modi\fcations that are con-\nsistent with the speci\fed packet format.\n4.6 The Control Program\nOnce tables and actions are de\fned, the only remaining\ntask is to specify the \row of control from one table to the\nnext. Control \row is speci\fed as a program via a collection\nof functions, conditionals, and table references.\nFigure 4: Flow chart for the mTag example.\nFigure 4 shows a graphical representation of the desired\ncontrol \row for the mTag implementation on edge switches.\nAfter parsing, the source check table veri\fes consistency\nbetween the received packet and the ingress port. For ex-\nample, mTags should only be seen on ports connected to\ncore switches. The source check also strips mTags fromthe packet, recording whether the packet had an mTag in\nmetadata. Tables later in the pipeline may match on this\nmetadata to avoid retagging the packet.\nThe local switching table is then executed. If this table\n\\misses,\" it indicates that the packet is not destined for a\nlocally connected host. In that case, the mTag table (de-\n\fned above) is applied to the packet. Both local and core\nforwarding control can be processed by the egress check\ntable which handles the case of an unknown destination by\nsending a noti\fcation up the SDN control stack.\nThe imperative representation of this packet processing\npipeline is as follows:\ncontrol main() {\n// Verify mTag state and port are consistent\ntable(source_check);\n// If no error from source_check, continue\nif (!defined(metadata.ingress_error)) {\n// Attempt to switch to end hosts\ntable(local_switching);\nif (!defined(metadata.egress_spec)) {\n// Not a known local host; try mtagging\ntable(mTag_table);\n}\n// Check for unknown egress state or\n// bad retagging with mTag.\ntable(egress_check);\n}\n}\n5. COMPILING A P4 PROGRAM\nFor a network to implement our P4 program, we need\na compiler to map the target-independent description onto\nthe target switch's speci\fc hardware or software platform.\nDoing so involves allocating the target's resources and gen-\nerating appropriate con\fguration for the device.\n5.1 Compiling Packet Parsers\nFor devices with programmable parsers, the compiler trans-\nlates the parser description into a parsing state machine,\nwhile for \fxed parsers, the compiler merely veri\fes that the\nparser description is consistent with the target's parser. De-\ntails of generating a state machine and state table entries\ncan be found in [16].\nTable 2 shows state table entries for the vlan and mTag\nsections of the parser ( x4.3). Each entry speci\fes the current\nstate, the \feld value to match, and the next state. Other\ncolumns are omitted for brevity.\nCurrent State Lookup Value Next State\nvlan 0xaaaa mTag\nvlan 0x800 ipv4\nvlan * stop\nmTag 0x800 ipv4\nmTag * stop\nTable 2: Parser state table entries for the mTag example.\nACM SIGCOMM Computer Communication Review\n93\nVolume 44, Number 3, July 2014\n<physical_index_6>\n"
        },
        {
          "title": "5.2 Compiling Control Programs",
          "start_index": 6,
          "end_index": 7,
          "node_id": "0014",
          "text": "<physical_index_6>\ncopy_field(mTag.ethertype, vlan.ethertype);\n// Set VLAN's ethertype to signal mTag\nset_field(vlan.ethertype, 0xaaaa);\nset_field(mTag.up1, up1);\nset_field(mTag.up2, up2);\nset_field(mTag.down1, down1);\nset_field(mTag.down2, down2);\n// Set the destination egress port as well\nset_field(metadata.egress_spec, egr_spec);\n}\nIf an action needs parameters (e.g., the up1value for the\nmTag), it is supplied from the match table at runtime.\nIn this example, the switch inserts the mTag after the\nVLAN tag, copies the VLAN tag's Ethertype into the mTag\nto indicate what follows, and sets the VLAN tag's Ethertype\nto0xaaaa to signal mTag. Not shown are the inverse action\nspeci\fcation that strips an mTag from a packet and the table\nto apply this action in edge switches.\nP4's primitive actions include:\n\u000fsetfield: Set a speci\fc \feld in a header to a value.\nMasked sets are supported.\n\u000fcopy field: Copy one \feld to another.\n\u000faddheader: Set a speci\fc header instance (and all its\n\felds) as valid.\n\u000fremove header: Delete (\\pop\") a header (and all its \felds)\nfrom a packet.\n\u000fincrement: Increment or decrement the value in a \feld.\n\u000fchecksum: Calculate a checksum over some set of header\n\felds (e.g., an IPv4 checksum).\nWe expect most switch implementations will restrict action\nprocessing to permit only header modi\fcations that are con-\nsistent with the speci\fed packet format.\n4.6 The Control Program\nOnce tables and actions are de\fned, the only remaining\ntask is to specify the \row of control from one table to the\nnext. Control \row is speci\fed as a program via a collection\nof functions, conditionals, and table references.\nFigure 4: Flow chart for the mTag example.\nFigure 4 shows a graphical representation of the desired\ncontrol \row for the mTag implementation on edge switches.\nAfter parsing, the source check table veri\fes consistency\nbetween the received packet and the ingress port. For ex-\nample, mTags should only be seen on ports connected to\ncore switches. The source check also strips mTags fromthe packet, recording whether the packet had an mTag in\nmetadata. Tables later in the pipeline may match on this\nmetadata to avoid retagging the packet.\nThe local switching table is then executed. If this table\n\\misses,\" it indicates that the packet is not destined for a\nlocally connected host. In that case, the mTag table (de-\n\fned above) is applied to the packet. Both local and core\nforwarding control can be processed by the egress check\ntable which handles the case of an unknown destination by\nsending a noti\fcation up the SDN control stack.\nThe imperative representation of this packet processing\npipeline is as follows:\ncontrol main() {\n// Verify mTag state and port are consistent\ntable(source_check);\n// If no error from source_check, continue\nif (!defined(metadata.ingress_error)) {\n// Attempt to switch to end hosts\ntable(local_switching);\nif (!defined(metadata.egress_spec)) {\n// Not a known local host; try mtagging\ntable(mTag_table);\n}\n// Check for unknown egress state or\n// bad retagging with mTag.\ntable(egress_check);\n}\n}\n5. COMPILING A P4 PROGRAM\nFor a network to implement our P4 program, we need\na compiler to map the target-independent description onto\nthe target switch's speci\fc hardware or software platform.\nDoing so involves allocating the target's resources and gen-\nerating appropriate con\fguration for the device.\n5.1 Compiling Packet Parsers\nFor devices with programmable parsers, the compiler trans-\nlates the parser description into a parsing state machine,\nwhile for \fxed parsers, the compiler merely veri\fes that the\nparser description is consistent with the target's parser. De-\ntails of generating a state machine and state table entries\ncan be found in [16].\nTable 2 shows state table entries for the vlan and mTag\nsections of the parser ( x4.3). Each entry speci\fes the current\nstate, the \feld value to match, and the next state. Other\ncolumns are omitted for brevity.\nCurrent State Lookup Value Next State\nvlan 0xaaaa mTag\nvlan 0x800 ipv4\nvlan * stop\nmTag 0x800 ipv4\nmTag * stop\nTable 2: Parser state table entries for the mTag example.\nACM SIGCOMM Computer Communication Review\n93\nVolume 44, Number 3, July 2014\n<physical_index_6>\n<physical_index_7>\n5.2 Compiling Control Programs\nThe imperative control-\row representation in x4.6 is a\nconvenient way to specify the logical forwarding behavior of\na switch, but does not explicitly call out dependencies be-\ntween tables or opportunities for concurrency. We therefore\nemploy a compiler to analyze the control program to identify\ndependencies and look for opportunities to process header\n\felds in parallel. Finally, the compiler generates the tar-\nget con\fguration for the switch. There are many potential\ntargets: for example, a software switch [17], a multicore soft-\nware switch [18], an NPU [19], a \fxed function switch [20],\nor a recon\fgurable match table (RMT) pipeline [2].\nAs discussed inx3, the compiler follows a two-stage com-\npilation process. It \frst converts the P4 control program\ninto an intermediate table dependency graph representation\nwhich it analyzes to determine dependencies between ta-\nbles. A target-speci\fc back-end then maps this graph onto\nthe switch's speci\fc resources.\nWe brie\ry examine how the mTag example would be im-\nplemented in di\u000berent kinds of switches:\nSoftware switches: A software switch provides complete\n\rexibility: the table count, table con\fguration, and parsing\nare under software control. The compiler directly maps the\nmTag table graph to switch tables. The compiler uses ta-\nble type information to constrain table widths, heights, and\nmatching criterion (e.g., exact, pre\fx, or wildcard) of each\ntable. The compiler might also optimize ternary or pre\fx\nmatching with software data structures.\nHardware switches with RAM and TCAM: A com-\npiler can con\fgure hashing to perform e\u000ecient exact-match-\ning using RAM, for the mTag table in edge switches. In\ncontrast, the core mTag forwarding table that matches on a\nsubset of tag bits would be mapped to TCAM.\nSwitches supporting parallel tables: The compiler\ncan detect data dependencies and arrange tables in parallel\nor in series. In the mTag example, the tables mTag table and\nlocal switching can execute in parallel up to the execution\nof the action of setting an mTag.\nSwitches that apply actions at the end of the pipe-\nline: For switches with action processing only at the end of\na pipeline, the compiler can tell intermediate stages to gen-\nerate metadata that is used to perform the \fnal writes. In\nthe mTag example, whether the mTag is added or removed\ncould be represented in metadata.\nSwitches with a few tables: The compiler can map\na large number of P4 tables to a smaller number of physi-\ncal tables. In the mTag example, the local switching could\nbe combined with the mTag table. When the controller in-\nstalls new rules at runtime, the compiler's rule translator\ncan \\compose\" the rules in the two P4 tables to generate\nthe rules for the single physical table.\n6. CONCLUSION\nThe promise of SDN is that a single control plane can di-rectly control a whole network of switches. OpenFlow sup-\nports this goal by providing a single, vendor-agnostic API.\nHowever, today's OpenFlow targets \fxed-function switches\nthat recognize a predetermined set of header \felds and that\nprocess packets using a small set of prede\fned actions. The\ncontrol plane cannot express how packets should be pro-\ncessed to best meet the needs of control applications.\nWe propose a step towards more \rexible switches whose\nfunctionality is speci\fed|and may be changed|in the \feld.\nThe programmer decides how the forwarding plane processes\npackets without worrying about implementation details. A\ncompiler transforms an imperative program into a table de-\npendency graph that can be mapped to many speci\fc target\nswitches, including optimized hardware implementations.\nWe emphasize that this is only a \frst step, designed as\na straw-man proposal for OpenFlow 2.0 to contribute to\nthe debate. In this proposal, several aspects of a switch re-\nmain unde\fned (e.g., congestion-control primitives, queuing\ndisciplines, tra\u000ec monitoring). However, we believe the ap-\nproach of having a con\fguration language|and compilers\nthat generate low-level con\fgurations for speci\fc targets|\nwill lead to future switches that provide greater \rexibility,\nand unlock the potential of software de\fned networks.\n7. REFERENCES\n[1] C. Kozanitis, J. Huber, S. Singh, and G. Varghese,\n\\Leaping multiple headers in a single bound:\nWire-speed parsing using the Kangaroo system,\" in\nIEEE INFOCOM , pp. 830{838, 2010.\n[2] P. Bosshart, G. Gibb, H.-S. Kim, G. Varghese,\nN. McKeown, M. Izzard, F. Mujica, and M. Horowitz,\n\\Forwarding metamorphosis: Fast programmable\nmatch-action processing in hardware for SDN,\" in\nACM SIGCOMM, 2013.\n[3] \\Intel Ethernet Switch Silicon FM6000.\"\nhttp://www.intel.com/content/dam/www/public/\nus/en/documents/white-papers/ethernet-switch-\nfm6000-sdn-paper.pdf.\n[4] N. Yadav and D. Cohn, \\OpenFlow Primitive Set.\"\nhttp://goo.gl/6qwbg, July 2011.\n[5] H. Song, \\Protocol-oblivious forwarding: Unleash the\npower of SDN through a future-proof forwarding\nplane,\" in SIGCOMM HotSDN Workshop , Aug. 2013.\n[6] \\Open\row forwarding abstractions working group\ncharter.\" http://goo.gl/TtLtw0, Apr. 2013.\n[7] M. Raju, A. Wundsam, and M. Yu, \\NOSIX: A\nlightweight portability layer for the SDN OS,\" ACM\nSIGCOMM Computer Communications Review, 2014.\n[8] V. Jeyakumar, M. Alizadeh, C. Kim, and D. Mazieres,\n\\Tiny packet programs for low-latency network\ncontrol and monitoring,\" in ACM SIGCOMM HotNets\nWorkshop, Nov. 2013.\n[9] A. Sivaraman, K. Winstein, S. Subramanian, and\nH. Balakrishnan, \\No silver bullet: Extending SDN to\nACM SIGCOMM Computer Communication Review\n94\nVolume 44, Number 3, July 2014\n<physical_index_7>\n"
        },
        {
          "title": "6. CONCLUSION",
          "start_index": 7,
          "end_index": 8,
          "node_id": "0015",
          "text": "<physical_index_7>\n5.2 Compiling Control Programs\nThe imperative control-\row representation in x4.6 is a\nconvenient way to specify the logical forwarding behavior of\na switch, but does not explicitly call out dependencies be-\ntween tables or opportunities for concurrency. We therefore\nemploy a compiler to analyze the control program to identify\ndependencies and look for opportunities to process header\n\felds in parallel. Finally, the compiler generates the tar-\nget con\fguration for the switch. There are many potential\ntargets: for example, a software switch [17], a multicore soft-\nware switch [18], an NPU [19], a \fxed function switch [20],\nor a recon\fgurable match table (RMT) pipeline [2].\nAs discussed inx3, the compiler follows a two-stage com-\npilation process. It \frst converts the P4 control program\ninto an intermediate table dependency graph representation\nwhich it analyzes to determine dependencies between ta-\nbles. A target-speci\fc back-end then maps this graph onto\nthe switch's speci\fc resources.\nWe brie\ry examine how the mTag example would be im-\nplemented in di\u000berent kinds of switches:\nSoftware switches: A software switch provides complete\n\rexibility: the table count, table con\fguration, and parsing\nare under software control. The compiler directly maps the\nmTag table graph to switch tables. The compiler uses ta-\nble type information to constrain table widths, heights, and\nmatching criterion (e.g., exact, pre\fx, or wildcard) of each\ntable. The compiler might also optimize ternary or pre\fx\nmatching with software data structures.\nHardware switches with RAM and TCAM: A com-\npiler can con\fgure hashing to perform e\u000ecient exact-match-\ning using RAM, for the mTag table in edge switches. In\ncontrast, the core mTag forwarding table that matches on a\nsubset of tag bits would be mapped to TCAM.\nSwitches supporting parallel tables: The compiler\ncan detect data dependencies and arrange tables in parallel\nor in series. In the mTag example, the tables mTag table and\nlocal switching can execute in parallel up to the execution\nof the action of setting an mTag.\nSwitches that apply actions at the end of the pipe-\nline: For switches with action processing only at the end of\na pipeline, the compiler can tell intermediate stages to gen-\nerate metadata that is used to perform the \fnal writes. In\nthe mTag example, whether the mTag is added or removed\ncould be represented in metadata.\nSwitches with a few tables: The compiler can map\na large number of P4 tables to a smaller number of physi-\ncal tables. In the mTag example, the local switching could\nbe combined with the mTag table. When the controller in-\nstalls new rules at runtime, the compiler's rule translator\ncan \\compose\" the rules in the two P4 tables to generate\nthe rules for the single physical table.\n6. CONCLUSION\nThe promise of SDN is that a single control plane can di-rectly control a whole network of switches. OpenFlow sup-\nports this goal by providing a single, vendor-agnostic API.\nHowever, today's OpenFlow targets \fxed-function switches\nthat recognize a predetermined set of header \felds and that\nprocess packets using a small set of prede\fned actions. The\ncontrol plane cannot express how packets should be pro-\ncessed to best meet the needs of control applications.\nWe propose a step towards more \rexible switches whose\nfunctionality is speci\fed|and may be changed|in the \feld.\nThe programmer decides how the forwarding plane processes\npackets without worrying about implementation details. A\ncompiler transforms an imperative program into a table de-\npendency graph that can be mapped to many speci\fc target\nswitches, including optimized hardware implementations.\nWe emphasize that this is only a \frst step, designed as\na straw-man proposal for OpenFlow 2.0 to contribute to\nthe debate. In this proposal, several aspects of a switch re-\nmain unde\fned (e.g., congestion-control primitives, queuing\ndisciplines, tra\u000ec monitoring). However, we believe the ap-\nproach of having a con\fguration language|and compilers\nthat generate low-level con\fgurations for speci\fc targets|\nwill lead to future switches that provide greater \rexibility,\nand unlock the potential of software de\fned networks.\n7. REFERENCES\n[1] C. Kozanitis, J. Huber, S. Singh, and G. Varghese,\n\\Leaping multiple headers in a single bound:\nWire-speed parsing using the Kangaroo system,\" in\nIEEE INFOCOM , pp. 830{838, 2010.\n[2] P. Bosshart, G. Gibb, H.-S. Kim, G. Varghese,\nN. McKeown, M. Izzard, F. Mujica, and M. Horowitz,\n\\Forwarding metamorphosis: Fast programmable\nmatch-action processing in hardware for SDN,\" in\nACM SIGCOMM, 2013.\n[3] \\Intel Ethernet Switch Silicon FM6000.\"\nhttp://www.intel.com/content/dam/www/public/\nus/en/documents/white-papers/ethernet-switch-\nfm6000-sdn-paper.pdf.\n[4] N. Yadav and D. Cohn, \\OpenFlow Primitive Set.\"\nhttp://goo.gl/6qwbg, July 2011.\n[5] H. Song, \\Protocol-oblivious forwarding: Unleash the\npower of SDN through a future-proof forwarding\nplane,\" in SIGCOMM HotSDN Workshop , Aug. 2013.\n[6] \\Open\row forwarding abstractions working group\ncharter.\" http://goo.gl/TtLtw0, Apr. 2013.\n[7] M. Raju, A. Wundsam, and M. Yu, \\NOSIX: A\nlightweight portability layer for the SDN OS,\" ACM\nSIGCOMM Computer Communications Review, 2014.\n[8] V. Jeyakumar, M. Alizadeh, C. Kim, and D. Mazieres,\n\\Tiny packet programs for low-latency network\ncontrol and monitoring,\" in ACM SIGCOMM HotNets\nWorkshop, Nov. 2013.\n[9] A. Sivaraman, K. Winstein, S. Subramanian, and\nH. Balakrishnan, \\No silver bullet: Extending SDN to\nACM SIGCOMM Computer Communication Review\n94\nVolume 44, Number 3, July 2014\n<physical_index_7>\n<physical_index_8>\nthe data plane,\" in ACM SIGCOMM HotNets\nWorkshop, Nov. 2013.\n[10] E. Kohler, R. Morris, B. Chen, J. Jannotti, and M. F.\nKaashoek, \\The Click modular router,\" ACM\nTransactions on Computer Systems, vol. 18,\npp. 263{297, Aug. 2000.\n[11] \\Multiprotocol Label Switching Charter.\"\nhttp://datatracker.ietf.org/wg/mpls/charter/.\n[12] R. Niranjan Mysore, A. Pamboris, N. Farrington,\nN. Huang, P. Miri, S. Radhakrishnan, V. Subramanya,\nand A. Vahdat, \\PortLand: A scalable fault-tolerant\nlayer 2 data center network fabric,\" in ACM\nSIGCOMM, pp. 39{50, Aug. 2009.\n[13] P. McCann and S. Chandra, \\PacketTypes: Abstract\nspeci\fcationa of network protocol messages,\" in ACM\nSIGCOMM, pp. 321{333, Aug. 2000.\n[14] G. Back, \\DataScript - A speci\fcation and scripting\nlanguage for binary data,\" in Generative Programming\nand Component Engineering , vol. 2487, pp. 66{77,\nLecture Notes in Computer Science, 2002.[15] K. Fisher and R. Gruber, \\PADS: A domain speci\fc\nlanguage for processing ad hoc data,\" in ACM\nConference on Programming Language Design and\nImplementation, pp. 295{304, June 2005.\n[16] G. Gibb, G. Varghese, M. Horowitz, and\nN. McKeown, \\Design principles for packet parsers,\"\ninANCS, pp. 13{24, 2013.\n[17] \\Open vSwitch website.\"\nhttp://www.openvswitch.org.\n[18] D. Zhou, B. Fan, H. Lim, M. Kaminsky, and D. G.\nAndersen, \\Scalable, high performance ethernet\nforwarding with CuckooSwitch,\" in CoNext,\npp. 97{108, 2013.\n[19] \\EZChip 240-Gigabit Network Processor for Carrier\nEthernet Applications.\"\nhttp:http://www.ezchip.com/p_np5.htm.\n[20] \\Broadcom BCM56850 Series.\"\nhttps://www.broadcom.com/products/Switching/\nData-Center/BCM56850-Series.\nACM SIGCOMM Computer Communication Review\n95\nVolume 44, Number 3, July 2014\n<physical_index_8>\n"
        },
        {
          "title": "7. REFERENCES",
          "start_index": 8,
          "end_index": 8,
          "node_id": "0016",
          "text": "<physical_index_8>\nthe data plane,\" in ACM SIGCOMM HotNets\nWorkshop, Nov. 2013.\n[10] E. Kohler, R. Morris, B. Chen, J. Jannotti, and M. F.\nKaashoek, \\The Click modular router,\" ACM\nTransactions on Computer Systems, vol. 18,\npp. 263{297, Aug. 2000.\n[11] \\Multiprotocol Label Switching Charter.\"\nhttp://datatracker.ietf.org/wg/mpls/charter/.\n[12] R. Niranjan Mysore, A. Pamboris, N. Farrington,\nN. Huang, P. Miri, S. Radhakrishnan, V. Subramanya,\nand A. Vahdat, \\PortLand: A scalable fault-tolerant\nlayer 2 data center network fabric,\" in ACM\nSIGCOMM, pp. 39{50, Aug. 2009.\n[13] P. McCann and S. Chandra, \\PacketTypes: Abstract\nspeci\fcationa of network protocol messages,\" in ACM\nSIGCOMM, pp. 321{333, Aug. 2000.\n[14] G. Back, \\DataScript - A speci\fcation and scripting\nlanguage for binary data,\" in Generative Programming\nand Component Engineering , vol. 2487, pp. 66{77,\nLecture Notes in Computer Science, 2002.[15] K. Fisher and R. Gruber, \\PADS: A domain speci\fc\nlanguage for processing ad hoc data,\" in ACM\nConference on Programming Language Design and\nImplementation, pp. 295{304, June 2005.\n[16] G. Gibb, G. Varghese, M. Horowitz, and\nN. McKeown, \\Design principles for packet parsers,\"\ninANCS, pp. 13{24, 2013.\n[17] \\Open vSwitch website.\"\nhttp://www.openvswitch.org.\n[18] D. Zhou, B. Fan, H. Lim, M. Kaminsky, and D. G.\nAndersen, \\Scalable, high performance ethernet\nforwarding with CuckooSwitch,\" in CoNext,\npp. 97{108, 2013.\n[19] \\EZChip 240-Gigabit Network Processor for Carrier\nEthernet Applications.\"\nhttp:http://www.ezchip.com/p_np5.htm.\n[20] \\Broadcom BCM56850 Series.\"\nhttps://www.broadcom.com/products/Switching/\nData-Center/BCM56850-Series.\nACM SIGCOMM Computer Communication Review\n95\nVolume 44, Number 3, July 2014\n<physical_index_8>\n"
        }
      ],
      "node_id": "0000",
      "text": "<physical_index_1>\nP4: Programming Protocol-Independent\nPacket Processors\nPat Bossharty, Dan Daly*, Glen Gibby, Martin Izzardy, Nick McKeownz, Jennifer Rexford**,\nCole Schlesinger**, Dan Talaycoy, Amin Vahdat{, George Varghesex, David Walker**\nyBarefoot Networks*IntelzStanford University**Princeton University{GooglexMicrosoft Research\nABSTRACT\nP4 is a high-level language for programming protocol-inde-\npendent packet processors. P4 works in conjunction with\nSDN control protocols like OpenFlow. In its current form,\nOpenFlow explicitly speci\fes protocol headers on which it\noperates. This set has grown from 12 to 41 \felds in a few\nyears, increasing the complexity of the speci\fcation while\nstill not providing the \rexibility to add new headers. In this\npaper we propose P4 as a strawman proposal for how Open-\nFlow should evolve in the future. We have three goals: (1)\nRecon\fgurability in the \feld: Programmers should be able\nto change the way switches process packets once they are\ndeployed. (2) Protocol independence: Switches should not\nbe tied to any speci\fc network protocols. (3) Target inde-\npendence: Programmers should be able to describe packet-\nprocessing functionality independently of the speci\fcs of the\nunderlying hardware. As an example, we describe how to\nuse P4 to con\fgure a switch to add a new hierarchical label.\n1. INTRODUCTION\nSoftware-De\fned Networking (SDN) gives operators pro-\ngrammatic control over their networks. In SDN, the con-\ntrol plane is physically separate from the forwarding plane,\nand one control plane controls multiple forwarding devices.\nWhile forwarding devices could be programmed in many\nways, having a common, open, vendor-agnostic interface\n(like OpenFlow) enables a control plane to control forward-\ning devices from di\u000berent hardware and software vendors.\nVersion Date Header Fields\nOF 1.0 Dec 2009 12 \felds (Ethernet, TCP/IPv4)\nOF 1.1 Feb 2011 15 \felds (MPLS, inter-table metadata)\nOF 1.2 Dec 2011 36 \felds (ARP, ICMP, IPv6, etc.)\nOF 1.3 Jun 2012 40 \felds\nOF 1.4 Oct 2013 41 \felds\nTable 1: Fields recognized by the OpenFlow standard\nThe OpenFlow interface started simple, with the abstrac-\ntion of a single table of rules that could match packets on a\ndozen header \felds (e.g., MAC addresses, IP addresses, pro-\ntocol, TCP/UDP port numbers, etc.). Over the past \fve\nyears, the speci\fcation has grown increasingly more com-\nplicated (see Table 1), with many more header \felds andmultiple stages of rule tables, to allow switches to expose\nmore of their capabilities to the controller.\nThe proliferation of new header \felds shows no signs of\nstopping. For example, data-center network operators in-\ncreasingly want to apply new forms of packet encapsula-\ntion (e.g., NVGRE, VXLAN, and STT), for which they re-\nsort to deploying software switches that are easier to extend\nwith new functionality. Rather than repeatedly extending\nthe OpenFlow speci\fcation, we argue that future switches\nshould support \rexible mechanisms for parsing packets and\nmatching header \felds, allowing controller applications to\nleverage these capabilities through a common, open inter-\nface (i.e., a new \\OpenFlow 2.0\" API). Such a general, ex-\ntensible approach would be simpler, more elegant, and more\nfuture-proof than today's OpenFlow 1.x standard.\nFigure 1: P4 is a language to con\fgure switches.\nRecent chip designs demonstrate that such \rexibility can\nbe achieved in custom ASICs at terabit speeds [1, 2, 3]. Pro-\ngramming this new generation of switch chips is far from\neasy. Each chip has its own low-level interface, akin to\nmicrocode programming. In this paper, we sketch the de-\nsign of a higher-level language for Programming Protocol-\nindependent Packet Processors (P4). Figure 1 shows the\nrelationship between P4|used to con\fgure a switch, telling\nit how packets are to be processed|and existing APIs (such\nas OpenFlow) that are designed to populate the forwarding\ntables in \fxed function switches. P4 raises the level of ab-\nstraction for programming the network, and can serve as a\nACM SIGCOMM Computer Communication Review\n88\nVolume 44, Number 3, July 2014\n<physical_index_1>\n"
    }
  ]
}